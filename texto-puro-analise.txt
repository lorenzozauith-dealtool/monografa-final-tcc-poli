% Monografia TCC - Projeto Vindex
% Template politex para Escola PolitÃ©cnica da USP
% Idioma principal: portuguÃªs brasileiro
% Pacote para URLs
% Pacotes grÃ¡ficos e utilitÃ¡rios
% Pacote de matemÃ¡tica que define  e outros comandos em ambiente matemÃ¡tico
% ConfiguraÃ§Ãµes para o pacote listings (cÃ³digos-fonte)
% ConfiguraÃ§Ã£o padrÃ£o do ambiente de listagens. Note que a vÃ­rgula apÃ³s a
% linguagem evita que o comentÃ¡rio interfira na definiÃ§Ã£o.
  basicstyle=,
  breaklines=true,
  keywordstyle=,
  commentstyle=,
  stringstyle=,
  numbers=left,
  numberstyle=,
  numbersep=5pt,
  language=C++, % (pode ser ajustado por listagem individual)
% InformaÃ§Ãµes de dados para CAPA e FOLHA DE ROSTO
Sistema de
DetecÃ§Ã£o de Acidentes e Alerta AutomÃ¡tico para Motociclistas
% Define os autores conforme o template politeX
Igor Teixeira Lacerda\\
\\
Lorenzo Zauith\\
\\
Rodrigo Costa de AraÃºjo
% Tipo de documento: TCC
% Departamento e Ã¡rea
% Orientador
% ========== Capa e folhas de rosto ==========
% ========== DedicatÃ³ria (opcional) ==========
% ========== Resumo ==========
Os acidentes motociclÃ­sticos representam uma das principais causas de mortalidade no trÃ¢nsito brasileiro. Segundo a AssociaÃ§Ã£o Brasileira de Medicina do TrÃ¡fego (ABRAMET), a cada 39 minutos um motociclista perde a vida no trÃ¢nsito
brasileiro, e a taxa de mortalidade por quilÃ´metro
rodado Ã© cerca de 30~vezes maior do que a de ocupantes de automÃ³veis. A
vulnerabilidade desses condutores agrava-se quando o acidente ocorre em
vias de baixa circulaÃ§Ã£o, Ã¡reas rurais ou estradas com pouca iluminaÃ§Ã£o
e monitoramento. Nesses cenÃ¡rios, o tempo atÃ© que alguÃ©m identifique o
acidente e acione o resgate pode ultrapassar a chamada â€œhora de ouroâ€,
intervalo de atÃ© 60 minutos apÃ³s um trauma grave, considerado crÃ­tico
para a sobrevivÃªncia . Estudos do National Highway Traffic Safety
Administration (NHTSA)  indicam que vÃ­timas de acidentes graves tÃªm atÃ©
60\% mais chances de sobreviver quando socorridas nos primeiros 30
minutos. Diante desse quadro, este trabalho propÃµe o
desenvolvimento de um sistema embarcado de baixo custo, fixado na
estrutura da motocicleta, capaz de detectar automaticamente acidentes
por meio de sensores inerciais, enviar alertas de emergÃªncia com
localizaÃ§Ã£o geogrÃ¡fica em tempo real e, adicionalmente, registrar
imagens do momento da colisÃ£o como apoio secundÃ¡rio para diagnÃ³stico ou
documentaÃ§Ã£o do ocorrido. O dispositivo Ã© composto por um
microcontrolador Raspberry Pi Zero 2W, um microcontrolador ESP32-C3
Super Mini, um sensor GY-BMI160 (acelerÃ´metro e giroscÃ³pio) e uma cÃ¢mera
grande angular de 160Â°, integrados em uma carcaÃ§a impressa em 3D
projetada para resistir a impactos. A lÃ³gica de funcionamento baseia-se
na anÃ¡lise de padrÃµes de aceleraÃ§Ã£o e variaÃ§Ã£o angular para detectar
quedas abruptas ou mudanÃ§as anormais de orientaÃ§Ã£o, desencadeando
automaticamente o protocolo de emergÃªncia sem necessidade de intervenÃ§Ã£o
do usuÃ¡rio. A transmissÃ£o dos dados Ã© feita via conexÃ£o Bluetooth,
enviando as coordenadas do acidente e uma mensagem prÃ©-configurada para
contatos de emergÃªncia ou serviÃ§os especializados. A cÃ¢mera, posicionada
com Ã¢ngulo amplo, atua como ferramenta auxiliar e pode registrar imagens
de forma instantÃ¢nea apÃ³s o acidente, gerando evidÃªncia visual Ãºtil. O
sistema Ã© alimentado por bateria recarregÃ¡vel com autonomia de
aproximadamente 10 horas de monitoramento contÃ­nuo. Com custo estimado
em R\$~300,00 por unidade, o projeto visa tornar acessÃ­vel uma
tecnologia crÃ­tica para mitigar o impacto de acidentes motociclÃ­sticos,
com potencial de aplicaÃ§Ã£o em escala nacional por Ã³rgÃ£os pÃºblicos,
seguradoras e fabricantes. AlÃ©m de seu carÃ¡ter social, a proposta
alinha-se Ã s tendÃªncias de seguranÃ§a ativa e resposta emergencial em
tempo real, reforÃ§ando o papel da engenharia embarcada na preservaÃ§Ã£o da
vida.
: seguranÃ§a veicular; acidentes de moto; sistemas
embarcados; detecÃ§Ã£o automÃ¡tica; resposta emergencial.
% ========== Abstract ==========
Motorcycle accidents are a
leading cause of traffic fatalities in Brazil. According to the
Brazilian Association of Traffic Medicine (ABRAMET), a motorcyclist dies
every 39 minutes in Brazil, and the fatality rate per kilometer traveled
is dozens of times higher than that of car
occupants. The vulnerability of these riders is
exacerbated when accidents occur on low-traffic roads, rural areas, or
poorly lit and monitored highways. In such situations, the time until an
accident is identified and rescue is activated can exceed the â€œgolden
hour,â€ a critical 60-minute window after severe trauma, vital for
survival. Studies by the National Highway Traffic Safety Administration
(NHTSA) indicate that severe accident victims have up to a 60\% higher
chance of survival when rescued within the first 30
minutes. Given this scenario, this work proposes the
development of a low-cost embedded system, mounted on the motorcycleâ€™s
frame, capable of automatically detecting accidents using inertial
sensors, sending real-time emergency alerts with geographical location,
and additionally recording images of the collision moment as secondary
support for diagnosis or documentation. The device comprises a Raspberry
Pi Zero 2W microcontroller, an ESP32-C3 Super Mini microcontroller, a
GY-BMI160 sensor (accelerometer and gyroscope), and a 160-degree
wide-angle camera, all integrated into a 3D-printed enclosure designed
to withstand impact. The systemâ€™s operational logic is based on
analyzing acceleration patterns and angular variations to detect abrupt
falls or abnormal orientation changes, automatically triggering the
emergency protocol without user intervention. Data transmission occurs
via Bluetooth connection, sending accident coordinates and a
pre-configured message to emergency contacts or specialized services.
The wide-angle camera acts as an auxiliary tool, instantly capturing
images during and after the accident, generating useful visual evidence.
The system is powered by a rechargeable battery, providing approximately
10 hours of continuous monitoring. With an estimated cost of R\$~300.00
per unit, this project aims to make critical technology accessible to
mitigate the impact of motorcycle accidents, with potential for national
application by public agencies, insurance companies, and manufacturers.
Beyond its social impact, the proposal aligns with trends in active
safety and real-time emergency response, reinforcing the role of
embedded engineering in preserving lives.
: vehicle safety; motorcycle accidents; embedded
systems; automatic crash detection; emergency response.
% ========== Listas (opcional) ==========
% ========== SumÃ¡rio ==========
% ========== Listas definidas pelo usuÃ¡rio (opcional) ==========
   AssociaÃ§Ã£o Brasileira de Medicina do TrÃ¡fego
    (Unidade Central de Processamento)
   FamÃ­lia de microcontroladores ESP32 (RISC-V 160~MHz com Bluetooth 5.0)
    (Sistema de Posicionamento Global)
    (Unidade de MediÃ§Ã£o Inercial)
    (Reconhecimento Ã“ptico de Caracteres)
   Requisito Funcional
   Requisito NÃ£o Funcional
    (Algoritmo de detecÃ§Ã£o de objetos em tempo real)
% Lista de sÃ­mbolos
   AceleraÃ§Ã£o gravitacional padrÃ£o ().
   Velocidade angular (em radianos ou graus por segundo).
   VariaÃ§Ã£o de uma grandeza (diferenÃ§a entre dois instantes ou estados).
% IntroduÃ§Ã£o
 A seguranÃ§a no trÃ¢nsito Ã© um desafio crÃ­tico nas
grandes cidades e rodovias. No contexto de transporte individual, os
motociclistas se destacam pela alta exposiÃ§Ã£o a riscos de acidentes
graves. Nas Ãºltimas dÃ©cadas, avanÃ§os em sistemas eletrÃ´nicos veiculares
tÃªm reduzido a mortalidade entre ocupantes de automÃ³veis (por meio de
airbags, freios ABS, etc.), porÃ©m motocicletas ainda carecem de
dispositivos equivalentes de proteÃ§Ã£o ativa e de sistemas automÃ¡ticos de
alerta pÃ³s-acidente. Tecnologias de chamada de emergÃªncia automÃ¡tica,
como o sistema  implementado em carros na UniÃ£o Europeia,
comprovam que a rÃ¡pida notificaÃ§Ã£o de acidentes pode salvar vidas,
diminuindo o tempo de resposta de equipes de resgate.
Entretanto, tais soluÃ§Ãµes ainda nÃ£o sÃ£o amplamente disponÃ­veis para
motocicletas.
Historicamente, a resposta a acidentes motociclÃ­sticos depende quase
exclusivamente de terceiros presenciarem o evento e acionar socorro. Em
Ã¡reas remotas ou horÃ¡rios de baixo movimento, um motociclista acidentado
pode ficar longos perÃ­odos sem assistÃªncia. Esse atraso no atendimento
mÃ©dico reduz drasticamente as chances de sobrevivÃªncia, conforme
destacam estatÃ­sticas da ABRAMET  e estudos internacionais . Pesquisas de Park   demonstram a relaÃ§Ã£o direta entre tempo prÃ©-hospitalar e desfechos em trauma, enquanto Brown   evidenciam que, em casos de hemorragia, cada minuto adicional de atraso estÃ¡ associado a aumento significativo na mortalidade.
Esse problema motivou pesquisas em sistemas de detecÃ§Ã£o automÃ¡tica de
acidentes utilizando sensores inerciais, dispositivos mÃ³veis e tÃ©cnicas
de telecomunicaÃ§Ã£o para envio de alertas.
Com o advento de sensores MEMS (Micro-Electro-Mechanical
Systems) acessÃ­veis e microcontroladores de baixo custo e baixo
consumo, tornou-se viÃ¡vel a construÃ§Ã£o de dispositivos embarcados
capazes de monitorar continuamente o movimento de um veÃ­culo e
identificar padrÃµes indicativos de colisÃ£o ou queda. Diversos trabalhos
exploraram o uso de acelerÃ´metros e giroscÃ³pios para esse
fim. Em paralelo, a difusÃ£o de smartphones
com sensores embutidos levou ao surgimento de aplicativos de detecÃ§Ã£o de
acidentes, embora com limitaÃ§Ãµes como a dependÃªncia de o
smartphone estar fixo no veÃ­culo e ligado no momento do acidente. Nesse
contexto, um dispositivo dedicado ao veÃ­culo, integrado ao motociclo,
pode oferecer maior confiabilidade e autonomia na detecÃ§Ã£o de acidentes.
 A motivaÃ§Ã£o principal deste projeto Ã© reduzir o
tempo entre a ocorrÃªncia de um acidente de moto e o atendimento Ã 
vÃ­tima. Conforme mencionado, a ``hora de ouro'' Ã© crucial para aumentar
a probabilidade de sobrevivÃªncia em traumas graves. No Brasil, onde
milhares de motociclistas transitam diariamente em condiÃ§Ãµes adversas,
um sistema capaz de automaticamente perceber um acidente e alertar
equipes de emergÃªncia ou contatos de confianÃ§a pode significar a
diferenÃ§a entre a vida e a morte em muitos casos.
AlÃ©m do aspecto vital, hÃ¡ tambÃ©m motivaÃ§Ã£o social e econÃ´mica. Acidentes
de moto representam custos elevados ao sistema de saÃºde e Ã  seguridade
com licenÃ§as mÃ©dicas, indenizaÃ§Ãµes e outros gastos, e mitigÃ¡-los ou minimizar suas
consequÃªncias traz benefÃ­cios coletivos. Segundo dados da AgÃªncia Brasil , a frota brasileira de motocicletas cresceu 42\% entre 2015 e 2024, alcanÃ§ando 35 milhÃµes de unidades, enquanto as mortes de motociclistas correspondem a 38,6\% dos Ã³bitos no trÃ¢nsito. Tecnologias de seguranÃ§a ativa
para motocicletas estÃ£o atrasadas em comparaÃ§Ã£o Ã s dos automÃ³veis, de
forma que este projeto busca contribuir para preencher essa lacuna,
alinhando-se Ã s iniciativas de  e mobilidade mais
segura.
Do ponto de vista tecnolÃ³gico, o projeto tambÃ©m Ã© motivado pela
oportunidade de integraÃ§Ã£o de diferentes Ã¡reas da Engenharia ElÃ©trica e
da ComputaÃ§Ã£o: sistemas embarcados, sensores inerciais, processamento de
sinais, comunicaÃ§Ã£o sem fio e desenvolvimento mÃ³vel. Implementar uma
soluÃ§Ã£o funcional exigiu aplicar e aprimorar conhecimentos teÃ³ricos em
cada um desses domÃ­nios, o que justifica academicamente a empreitada
como um Trabalho de ConclusÃ£o de Curso desafiador e enriquecedor.
 A relevÃ¢ncia deste trabalho pode ser avaliada em
mÃºltiplas dimensÃµes. Sob o prisma da Engenharia, trata-se de um esforÃ§o
de inovaÃ§Ã£o incremental, combinando tecnologias existentes de forma
original para solucionar um problema real. Embora sensores e
comunicaÃ§Ãµes sem fio sejam amplamente usados em outros contextos, sua
aplicaÃ§Ã£o focada em seguranÃ§a de motociclistas ainda Ã© limitada. O
sistema proposto diferencia-se por buscar um equilÃ­brio entre baixo
custo e alto desempenho, viabilizando sua adoÃ§Ã£o em larga escala,
inclusive por Ã³rgÃ£os pÃºblicos em frotas de motofrete ou
programas de seguridade para motociclistas, e empresas seguradoras para
reduÃ§Ã£o de sinistralidade.
Em termos sociais, o projeto atende a uma demanda urgente de saÃºde
pÃºblica. Segundo a ABRAMET, os acidentes com motos jÃ¡ configuram uma
epidemia silenciosa nas emergÃªncias hospitalares. Cada minuto de reduÃ§Ã£o
no tempo de resposta do resgate pode aumentar significativamente a
chance de sobrevivÃªncia e reduzir sequelas permanentes nas vÃ­timas.
Assim, o impacto potencial de um sistema que agilize a chegada do
socorro Ã© enorme, salvando vidas e diminuindo o sofrimento de famÃ­lias.
No Ã¢mbito acadÃªmico e de pesquisa, esta monografia documenta os desafios
e soluÃ§Ãµes encontrados no desenvolvimento de um sistema
 ciberfÃ­sico complexo em pequena escala. A
documentaÃ§Ã£o minuciosa de falhas, decisÃµes de projeto e desempenho
obtido contribui para a literatura de projetos similares, servindo de
referÃªncia para futuros desenvolvimentos de seguranÃ§a veicular e IoT
() aplicada ao trÃ¢nsito.
 Dado o exposto, o problema especÃ­fico
que este trabalho se propÃµe a resolver Ã©: Como detectar
automaticamente um acidente envolvendo uma motocicleta e notificar, de
forma confiÃ¡vel e imediata, os contatos de emergÃªncia ou serviÃ§os de
resgate, fornecendo a localizaÃ§Ã£o exata e informaÃ§Ãµes contextuais do
evento?
Essa declaraÃ§Ã£o de problema envolve diversos subproblemas tÃ©cnicos interconectados. Primeiramente, Ã© necessÃ¡rio determinar como distinguir, via sensores embarcados, um acidente verdadeiro de eventos cotidianos como buracos, frenagens bruscas normais ou inclinaÃ§Ãµes em curvas. AlÃ©m disso, deve-se garantir que o alerta chegue rapidamente a um destinatÃ¡rio, mesmo em condiÃ§Ãµes adversas como sinal celular fraco ou quando o motociclista estiver inconsciente. Por fim, cabe investigar quais informaÃ§Ãµes adicionais podem ser fornecidas para melhorar a eficiÃªncia do socorro ou registro do incidente, como imagens do local ou identificaÃ§Ã£o de placa de veÃ­culo envolvido.
Em resumo, o problema central reside na criaÃ§Ã£o de um sistema de
detecÃ§Ã£o de acidentes motociclÃ­sticos que seja autÃ´nomo, confiÃ¡vel e
reproduzÃ­vel, cobrindo desde a monitoraÃ§Ã£o do veÃ­culo atÃ© a comunicaÃ§Ã£o
pÃ³s-acidente.
 A necessidade de tal sistema
torna-se evidente pelos nÃºmeros alarmantes e casos recorrentes de
motociclistas que ficam sem atendimento em tempo hÃ¡bil. No dia-a-dia,
muitos motociclistas trafegam sozinhos por trajetos pouco movimentados;
um deslize, colisÃ£o ou mesmo mal sÃºbito pode deixÃ¡-los caÃ­dos sem que
ninguÃ©m testemunhe imediatamente. Assim, existe uma necessidade clara de
um "anjo da guarda eletrÃ´nico" para esses condutores: um dispositivo
sempre alerta que, em caso de acidente, automaticamente chame por ajuda.
Do ponto de vista dos usuÃ¡rios (motociclistas e seus familiares), a
tranquilidade proporcionada por saber que existe um sistema de alerta
automÃ¡tico Ã© um fator de necessidade intangÃ­vel, relacionado Ã  seguranÃ§a
psicolÃ³gica. Para os serviÃ§os de emergÃªncia, um aviso prÃ©vio com
coordenadas precisas agiliza a logÃ­stica de atendimento. Para Ã³rgÃ£os de
trÃ¢nsito e seguradoras, hÃ¡ necessidade de dados mais confiÃ¡veis sobre
acidentes para anÃ¡lises estatÃ­sticas e apuraÃ§Ã£o de causas; um sistema
embarcado pode registrar dados do momento do acidente, atendendo tambÃ©m
a essa necessidade secundÃ¡ria.
Em suma, a necessidade abrange mÃºltiplos pÃºblicos: para motociclistas e familiares, representa a garantia de socorro rÃ¡pido em caso de acidente, mesmo quando o condutor estiver incapacitado de pedir ajuda; para autoridades e serviÃ§os mÃ©dicos, significa o recebimento de alerta geolocalizado que permite otimizar o tempo-resposta; e para seguradoras e pesquisadores, constitui o registro de informaÃ§Ãµes do acidente, incluindo dinÃ¢mica e imagens, que auxilia em processos de indenizaÃ§Ã£o e estudos de seguranÃ§a viÃ¡ria.
 Antes de partir para os requisitos
tÃ©cnicos, Ã© importante traduzir as necessidades acima em requisitos de
alto nÃ­vel, do ponto de vista do usuÃ¡rio final e do mercado. Esses
requisitos de marketing orientam as caracterÃ­sticas gerais que o produto
deve possuir para ser viÃ¡vel e atrativo. 
As necessidades de marketing identificadas para o sistema incluem um preo acess\'ivel  com custo unit\'ario em torno de R\$300--400  para viabilizar ampla ado\~ao; instala\~ao simples e acoplamento direto no guid\~ao ou chassi, permitindo que o pr\'oprio usu\'ario instale o dispositivo com m\'nima interven\~ao t\'ecnica; confiabilidade, com baixo \'ndice de falsos alarmes e mecanismos de confirma\~ao manual ou automatizada; autonomia de funcionamento de 8--10 horas em uso t\'ipico; integra\~ao com smartphone para envio de alertas, utilizando Bluetooth e internet m\'ovel; robustez, com resist\^encia a impactos, poeira e chuva; e valor adicional, oferecendo telemetria, estat\'isticas de pilotagem ou rastreamento que agreguem benef\'icios percebidos al\'em do alerta de acidente.
%de alto nÃ­vel identificados, foram definidos os requisitos de
Foram definidos os requisitos de engenharia do sistema de detecÃ§Ã£o de acidentes e alerta automÃ¡tico para motociclistas. Esses requisitos foram divididos em requisitos funcionais (RF) e requisitos nÃ£oâ€‘funcionais (RNF), conforme resumido nas Tabelas~ e~. Os requisitos funcionais descrevem as funÃ§Ãµes e comportamentos que o sistema deve realizar, enquanto os requisitos nÃ£oâ€‘funcionais estabelecem restriÃ§Ãµes e parÃ¢metros de qualidade.
  Na Tabela
, sÃ£o listados os principais requisitos funcionais
levantados para o projeto, codificados como RF-01, RF-02, etc.:
 p0.78
 &  \\
RF-01 & : O dispositivo embarcado (ESP32-C3 + sensor inercial) deve monitorar continuamente aceleraÃ§Ã£o e rotaÃ§Ã£o da motocicleta, identificando padrÃµes tÃ­picos de queda ou colisÃ£o brusca. \\
RF-02 & : Ao detectar um evento de acidente (critÃ©rio de detecÃ§Ã£o atendido), o ESP32-C3 deverÃ¡ gerar um sinal de ativaÃ§Ã£o via GPIO para ``acordar'' o microcontrolador Raspberry Pi Zero 2W, que normalmente permanece em modo de baixo consumo. \\
RF-03 & : O Raspberry Pi, ao ser despertado, deverÃ¡ realizar o registro do contexto do acidente. Isso inclui capturar, em modo , uma sequÃªncia curta de imagens (ou um vÃ­deo de poucos segundos) atravÃ©s da cÃ¢mera grande angular, de forma a obter registro visual do momento do impacto e instantes subsequentes. \\
RF-04 & : Os dados capturados (imagens ou vÃ­deo, e dados do evento como aceleraÃ§Ã£o pico, horÃ¡rio, etc.) deverÃ£o ser enviados do dispositivo embarcado para o smartphone do usuÃ¡rio via conexÃ£o Bluetooth Low Energy (BLE). \\
RF-05 & : O aplicativo mÃ³vel (smartphone) deve receber os dados do acidente e entÃ£o executar processamento adicional. Especificamente, deve: (a) Extrair de imagens recebidas a placa de eventual veÃ­culo envolvido, usando algoritmo de detecÃ§Ã£o de objetos (p.\,ex. YOLO) seguido de OCR para ler os caracteres da placa; (b) Compilar uma mensagem de alerta contendo localizaÃ§Ã£o geogrÃ¡fica (via GPS do smartphone), horÃ¡rio e, opcionalmente, uma foto do acidente com a placa destacada. \\
RF-06 & : O aplicativo deverÃ¡ entÃ£o enviar automaticamente um alerta de emergÃªncia aos destinatÃ¡rios predefinidos (contatos de confianÃ§a do motociclista e/ou serviÃ§os de resgate). Esse alerta pode ser realizado via mensagem SMS, e-mail ou integraÃ§Ã£o com aplicativos de mensagem ( utilizando a API do Telegram), incluindo as informaÃ§Ãµes relevantes (localizaÃ§Ã£o, identificaÃ§Ã£o do veÃ­culo, etc.). \\
RF-07 & : O sistema deve incluir uma forma do usuÃ¡rio cancelar o alerta nos casos de falso acionamento ou acidentes sem gravidade. Por exemplo, o aplicativo mÃ³vel pode exibir um aviso sonoro e visual por alguns segundos antes de disparar a notificaÃ§Ã£o, permitindo que o motociclista consciente cancele o envio. Caso nÃ£o haja cancelamento em tempo hÃ¡bil, assume-se emergÃªncia real e o alerta Ã© concluÃ­do. \\
RF-08 & : Adicionalmente, o sistema deverÃ¡ registrar dados de telemetria do percurso (aceleraÃ§Ãµes extremas, velocidade estimada, eventos de frenagem brusca) em uma base de dados remota ou local. Esses dados podem ser usados para anÃ¡lise posterior do comportamento do piloto e para fornecimento de evidÃªncias em caso de acidentes (trajetÃ³ria antes do acidente, por exemplo). \\
Os requisitos funcionais acima garantem que o sistema desempenhe as
funÃ§Ãµes essenciais para detectar e reportar acidentes de forma autÃ´noma
e confiÃ¡vel. A implementaÃ§Ã£o de cada um deles Ã© detalhada nos capÃ­tulos
de desenvolvimento. Vale notar que o RF-08 (telemetria) Ã© um
 funcional que agrega valor, embora nÃ£o seja estritamente
necessÃ¡rio para o atendimento emergencial imediato.
 AlÃ©m das funÃ§Ãµes, foram
estabelecidos requisitos nÃ£o-funcionais que o sistema deve satisfazer,
apresentados na Tabela . Esses RNFs dizem respeito ao
desempenho, restriÃ§Ãµes fÃ­sicas, usabilidade e outros atributos de
qualidade:
% VersÃ£o original da Tabela de Requisitos NÃ£oâ€‘Funcionais.
% A formataÃ§Ã£o aqui foi ajustada para evitar erros de alinhamento,
% porÃ©m todo o conteÃºdo textual foi preservado integralmente.
 p0.78
 &  \\
RNF-01 & : O sistema embarcado deve operar por pelo menos 10 horas contÃ­nuas sem recarga de bateria, considerando atÃ© 2 detecÃ§Ãµes de acidente por dia. Esse requisito visa atender o uso tÃ­pico diÃ¡rio (trajetos de trabalho, viagens curtas) sem depender de recarga frequente. \\
RNF-02 & : A carcaÃ§a do dispositivo deve proteger os componentes contra impactos de colisÃ£o e vibraÃ§Ãµes intensas. Espera-se que o equipamento continue funcional (ou ao menos preserve os dados capturados) mesmo apÃ³s o acidente. AlÃ©m disso, deve ter algum grau de proteÃ§Ã£o ambiental, sendo resistente a poeira e respingos d'Ã¡gua (equivalente a IP54 ou superior). \\
RNF-03 & : O algoritmo de detecÃ§Ã£o deve equilibrar sensibilidade e especificidade, acionando em casos de acidente verdadeiro (> 95\% de detecÃ§Ãµes) e evitando falsos alarmes em situaÃ§Ãµes nÃ£o crÃ­ticas (< 5\% de falsos positivos). Esses valores servem como meta de projeto. Estudos mostram ser comum adotar limiares na faixa de 3--4~ de aceleraÃ§Ã£o para distinguir colisÃµes, ajustados experimentalmente para minimizar disparos indevidos. \\
RNF-04 & : O intervalo de tempo entre a detecÃ§Ã£o do acidente e o envio do alerta ao contato de emergÃªncia deve ser o menor possÃ­vel. A meta estabelecida foi de no mÃ¡ximo 30 segundos para envio da primeira notificaÃ§Ã£o (mensagem de socorro bÃ¡sica com localizaÃ§Ã£o). A disponibilizaÃ§Ã£o de dados complementares (imagens, vÃ­deo) pode ocorrer em segundo plano, em atÃ© 2 minutos, sem comprometer o aviso inicial. Essa rapidez garante alinhamento com a necessidade de atendimento imediato. \\
RNF-05 & : O aplicativo mÃ³vel deve ser intuitivo e de operaÃ§Ã£o simples. Deve iniciar automaticamente com o sistema do smartphone e permanecer rodando em segundo plano enquanto o usuÃ¡rio estiver pilotando, conectando-se ao dispositivo via BLE sem requerer intervenÃ§Ã£o manual a cada uso. Em caso de acidente, a interface deve avisar claramente o usuÃ¡rio e solicitar confirmaÃ§Ã£o para cancelar ou aceitar o envio do alerta (conforme RF-07). TambÃ©m devem ser exibidas informaÃ§Ãµes Ãºteis, como nÃ­vel de bateria do dispositivo, status da conexÃ£o e Ãºltimo endereÃ§o conhecido. \\
RNF-06 & : A comunicaÃ§Ã£o BLE entre o mÃ³dulo embarcado e o smartphone deve manter-se estÃ¡vel dentro de um raio de pelo menos 5~m (considerando que o celular pode estar no bolso do usuÃ¡rio ou acoplado no guidÃ£o). AlÃ©m disso, o sistema deve tolerar desconexÃµes temporÃ¡rias (por exemplo, se o BLE falhar momentaneamente, tentar reconectar automaticamente). Para o envio de alertas a contatos remotos, depende-se da conectividade do smartphone (3G/4G/5G ou Wi-Fi); portanto, o aplicativo deve lidar com indisponibilidade de rede, enviando assim que houver sinal ou armazenando o alerta para reenvio. \\
RNF-07 & : O design do sistema de software deve facilitar futura compatibilidade multi-plataforma. Nesta primeira versÃ£o o aplicativo foi desenvolvido para iOS (Swift), mas espera-se que o nÃºcleo da soluÃ§Ã£o seja portÃ¡til para Android em projetos futuros. Os protocolos de comunicaÃ§Ã£o e formatos de dados devem ser padronizados e documentados (por exemplo, uso de JSON para mensagens via BLE), garantindo que novos  possam ser implementados sem necessidade de alterar o dispositivo embarcado. \\
% Tabela revisada dos requisitos nÃ£o-funcionais (parte 1)
 p0.82
 &  \\
RNF-01 & : O sistema embarcado deve operar por pelo menos 10 horas contÃ­nuas sem recarga de bateria, considerando atÃ© 2 detecÃ§Ãµes de acidente por dia. Esse requisito visa atender o uso tÃ­pico diÃ¡rio (trajetos de trabalho, viagens curtas) sem depender de recarga frequente. \\
RNF-02 & : A carcaÃ§a do dispositivo deve proteger os componentes contra impactos de colisÃ£o e vibraÃ§Ãµes intensas. Espera-se que o equipamento continue funcional (ou ao menos preserve os dados capturados) mesmo apÃ³s o acidente. AlÃ©m disso, deve ter algum grau de proteÃ§Ã£o ambiental, sendo resistente a poeira e respingos d'Ã¡gua (equivalente a IP54 ou superior). \\
RNF-03 & : O algoritmo de detecÃ§Ã£o deve equilibrar sensibilidade e especificidade, acionando em casos de acidente verdadeiro (> 95\% de detecÃ§Ãµes) e evitando falsos alarmes em situaÃ§Ãµes nÃ£o crÃ­ticas (< 5\% de falsos positivos). Esses valores servem como meta de projeto. Estudos mostram ser comum adotar limiares na faixa de 3--4~ de aceleraÃ§Ã£o para distinguir colisÃµes, ajustados experimentalmente para minimizar disparos indevidos. \\
RNF-04 & : O intervalo de tempo entre a detecÃ§Ã£o do acidente e o envio do alerta ao contato de emergÃªncia deve ser o menor possÃ­vel. A meta estabelecida foi de no mÃ¡ximo 30 segundos para envio da primeira notificaÃ§Ã£o (mensagem de socorro bÃ¡sica com localizaÃ§Ã£o). A disponibilizaÃ§Ã£o de dados complementares (imagens, vÃ­deo) pode ocorrer em segundo plano, em atÃ© 2 minutos, sem comprometer o aviso inicial. Essa rapidez garante alinhamento com a necessidade de atendimento imediato. \\
RNF-05 & : O aplicativo mÃ³vel deve ser intuitivo e de operaÃ§Ã£o simples. Deve iniciar automaticamente com o sistema do smartphone e permanecer rodando em segundo plano enquanto o usuÃ¡rio estiver pilotando, conectando-se ao dispositivo via BLE sem requerer intervenÃ§Ã£o manual a cada uso. Em caso de acidente, a interface deve avisar claramente o usuÃ¡rio e solicitar confirmaÃ§Ã£o para cancelar ou aceitar o envio do alerta (conforme RF-07). TambÃ©m devem ser exibidas informaÃ§Ãµes Ãºteis, como nÃ­vel de bateria do dispositivo, status da conexÃ£o e Ãºltimo endereÃ§o conhecido. \\
RNF-06 & : A comunicaÃ§Ã£o BLE entre o mÃ³dulo embarcado e o smartphone deve manter-se estÃ¡vel dentro de um raio de pelo menos 5~m (considerando que o celular pode estar no bolso do usuÃ¡rio ou acoplado no guidÃ£o). AlÃ©m disso, o sistema deve tolerar desconexÃµes temporÃ¡rias (por exemplo, se o BLE falhar momentaneamente, tentar reconectar automaticamente). Para o envio de alertas a contatos remotos, depende-se da conectividade do smartphone (3G/4G/5G ou Wi-Fi); portanto, o aplicativo deve lidar com indisponibilidade de rede, enviando assim que houver sinal ou armazenando o alerta para reenvio. \\
 p0.82
 &  \\
RNF-07 & : O design do sistema de software deve facilitar futura compatibilidade multi-plataforma. Nesta primeira versÃ£o o aplicativo foi desenvolvido para iOS (Swift), mas espera-se que o nÃºcleo da soluÃ§Ã£o seja portÃ¡til para Android em projetos futuros. Os protocolos de comunicaÃ§Ã£o e formatos de dados devem ser padronizados e documentados (por exemplo, uso de JSON para mensagens via BLE), garantindo que novos  possam ser implementados sem necessidade de alterar o dispositivo embarcado. \\
Os requisitos nÃ£o-funcionais delineados acima guiaram as decisÃµes de
projeto em termos de escolha de componentes (por exemplo, seleÃ§Ã£o de um
microcontrolador de ultrabaixo consumo para atender RNF-01), calibraÃ§Ã£o
do algoritmo de detecÃ§Ã£o (RNF-03) e arquitetura de software (RNF-05 e
RNF-07). Durante o desenvolvimento, a satisfaÃ§Ã£o de cada RNF foi
avaliada e, quando necessÃ¡rio, ajustes foram realizados para cumpri-los
(conforme serÃ¡ discutido nos Resultados).
 Tendo definidos os requisitos, Ã© Ãºtil
apresentÃ¡-los de forma hierÃ¡rquica sob a perspectiva dos objetivos do
projeto. A  apresentada na Figura~ ilustra os objetivos
gerais e especÃ­ficos do sistema, relacionando-os aos requisitos
correspondentes:
  % Objetivo geral
   (objetivo-geral)
    \ de detec\~ao autom\'atica de acidentes de moto\ alerta imediato;
  % Objetivos espec\'ificos - n\'ivel 1
   (detectar)
    \ inerciais;
   (acelerometro)
    Aceler\^ometro\\(detectar impacto);
   (giroscopio)
    Girosc\'opio\\(detectar queda);
   (transmitir)
    \\(Comunica\~ao);
   (bluetooth)
    Bluetooth LE\\(ESP32-C3  App);
   (internet)
    Internet\\(App  Contatos);
   (registrar)
    \\(Vis\~ao computacional);
   (camera)
    C\^amera 160Â°\\(imagens/v\'ideo);
   (ocr)
    YOLO + OCR\\(placa ve\'iculo);
  % Setas de relacionamento
   (objetivo-geral) -- (detectar);
   (detectar) -- (acelerometro);
   (detectar) -- (giroscopio);
   (objetivo-geral) -- (transmitir);
   (transmitir) -- (bluetooth);
   (transmitir) -- (internet);
   (objetivo-geral) -- (registrar);
   (registrar) -- (camera);
   (registrar) -- (ocr);
Conforme a figura , o objetivo geral de prover
um  desdobra-se em objetivos
especÃ­ficos: (1)  de forma confiÃ¡vel, o que
remete ao uso combinado de acelerÃ´metro e giroscÃ³pio para identificar
quedas ou colisÃµes; (2)  de maneira rÃ¡pida
aos destinatÃ¡rios apropriados, envolvendo tanto a comunicaÃ§Ã£o local
(Bluetooth) quanto o envio remoto (internet); e (3) registrar
evidÃªncias visuais que enriqueÃ§am as informaÃ§Ãµes do acidente, objetivo
atendido pelo mÃ³dulo de cÃ¢mera e algoritmos de visÃ£o computacional
(detecÃ§Ã£o de placa via YOLO + OCR). Cada um desses objetivos especÃ­ficos
se vincula a requisitos funcionais e nÃ£o-funcionais descritos nas seÃ§Ãµes
anteriores.
% Estado da Arte
Este capÃ­tulo aborda os conceitos teÃ³ricos e as soluÃ§Ãµes existentes
relacionadas ao problema em questÃ£o, bem como as tendÃªncias atuais que
norteiam o desenvolvimento de sistemas de detecÃ§Ã£o automÃ¡tica de
acidentes. O objetivo Ã© situar o presente trabalho no contexto das
pesquisas e tecnologias jÃ¡ estabelecidas, identificando os diferenciais
e inovaÃ§Ãµes propostos.
A detecÃ§Ã£o de acidentes motociclÃ­sticos de forma automÃ¡tica requer compreender alguns conceitos fundamentais de~engenharia. Estes sÃ£o apresentados de forma integrada nas subseÃ§Ãµes seguintes.
AcelerÃ´metros e giroscÃ³pios MEMS constituem o nÃºcleo de sistemas de detecÃ§Ã£o de queda. Um acelerÃ´metro triaxial mede as componentes de aceleraÃ§Ã£o ao longo dos eixos X, Y e Z do dispositivo, incluindo tanto aceleraÃ§Ã£o dinÃ¢mica (movimento) quanto a componente estÃ¡tica da gravidade. Um giroscÃ³pio triaxial mede a velocidade angular (rotaÃ§Ã£o) em torno de trÃªs eixos. A combinaÃ§Ã£o de ambos em uma Unidade de MediÃ§Ã£o Inercial (IMU) permite inferir a orientaÃ§Ã£o do veÃ­culo e detectar mudanÃ§as abruptas de velocidade ou inclinaÃ§Ã£o. Conforme demonstrado por Fauzi  , sistemas baseados em ESP32 com sensores MPU6050 apresentam excelente desempenho na detecÃ§Ã£o de quedas de motocicletas. Uma queda lateral de moto envolve tipicamente rÃ¡pida variaÃ§Ã£o angular, com a motocicleta inclinando-se alÃ©m do Ã¢ngulo normal de curva, seguida de desaceleraÃ§Ã£o brusca ao atingir o solo . Esses padrÃµes podem ser identificados processando os sinais do acelerÃ´metro e giroscÃ³pio.
A aceleraÃ§Ã£o Ã© frequentemente expressa em unidades de  (aceleraÃ§Ã£o da gravidade, aproximadamente 9,81~m/sÂ²). Impactos severos podem gerar picos de vÃ¡rias vezes . Estudos em detecÃ§Ã£o de colisÃµes automotivas definem limiares para disparo de airbags na faixa de 3 a 5~ por pelo menos 50~ms. Para motocicletas, um limiar de 4~ foi citado como indicativo de acidente em estudos do NHTSA, ajustado experimentalmente para minimizar disparos indevidos . Em nosso projeto, estabelecemos via testes prÃ¡ticos um valor de aproximadamente 3,5~ como ponto de disparo, levando em conta a sensibilidade do sensor e as dinÃ¢micas tÃ­picas de pilotagem. AlÃ©m do pico de aceleraÃ§Ã£o, utilizamos tambÃ©m um critÃ©rio de variaÃ§Ã£o angular abrupta.
Para transmitir os alertas do dispositivo embarcado atÃ© um destinatÃ¡rio remoto, Ã© necessÃ¡ria alguma forma de comunicaÃ§Ã£o sem fio. Duas frentes foram utilizadas: comunicaÃ§Ã£o de curto alcance entre o dispositivo e o smartphone via Bluetooth Low Energy (BLE) e comunicaÃ§Ã£o de longo alcance do smartphone com a internet atravÃ©s de redes 3G/4G ou Wi-Fi. O BLE foi escolhido por seu baixo consumo de energia e suporte nativo em smartphones modernos, alÃ©m de perfis apropriados para envio de dados esporÃ¡dicos como o perfil GATT. A velocidade de transferÃªncia do BLE Ã© limitada, tipicamente centenas de kilobits por segundo, mas suficiente para dados de telemetria e imagens comprimidas. O envio de notificaÃ§Ãµes aos contatos remotos aproveita a conectividade do smartphone, seja via redes celulares ou Wi-Fi, por meio de protocolos de internet como HTTP e MQTT. Dessa forma, o smartphone atua como gateway, encapsulando as informaÃ§Ãµes do acidente e enviando-as a um servidor ou diretamente aos destinatÃ¡rios.
Com os avanÃ§os em visÃ£o computacional, tornou-se possÃ­vel executar tarefas como detecÃ§Ã£o de objetos e OCR diretamente em smartphones. O algoritmo  (YOLO) Ã© uma arquitetura de detecÃ§Ã£o de objetos em tempo real baseada em redes neurais convolucionais, capaz de localizar e classificar objetos em imagens rapidamente . Trabalhos recentes, como o de Yan  , demonstram a eficÃ¡cia de sistemas ALPR () baseados em YOLO para detecÃ§Ã£o e classificaÃ§Ã£o de veÃ­culos. Para placas brasileiras especificamente, Montazzolli e Jung  desenvolveram um sistema de detecÃ§Ã£o e reconhecimento em tempo real usando redes neurais convolucionais profundas. Neste projeto, adotamos uma variante moderna da famÃ­lia YOLO para detectar a placa de um veÃ­culo envolvido no acidente. ApÃ³s detectar a placa, aplica-se OCR para extrair a sequÃªncia alfanumÃ©rica, utilizando o framework  da Apple que obtÃ©m bons resultados quando configurado adequadamente.
O desenvolvimento de um aplicativo mÃ³vel dedicado para iOS permitiu integrar todas as funcionalidades voltadas ao usuÃ¡rio: recebimento de dados via BLE, alerta sonoro e visual de acidente detectado, cancelamento por parte do piloto e envio de notificaÃ§Ãµes a contatos. Optamos por utilizar um serviÃ§o de backend em nuvem para intermediar o envio de mensagens, devido a restriÃ§Ãµes do iOS em enviar SMS ou mensagens automaticamente. Foi utilizado o serviÃ§o Supabase, uma plataforma BaaS () de cÃ³digo aberto, para armazenar os dados dos eventos e acionar um bot do Telegram via API, responsÃ¡vel por enviar a mensagem de alerta ao contato guardiÃ£o. Esse arranjo contorna limitaÃ§Ãµes de notificaÃ§Ãµes push em aplicativos nÃ£o publicados e provÃª escalabilidade, permitindo que mÃºltiplos guardiÃµes sejam notificados via um canal seguro enquanto os dados ficam registrados na nuvem para consulta posterior.
 Apresentamos
trabalhos acadÃªmicos, produtos comerciais e tecnologias que servem de
referÃªncia ou contraste para o Projeto Vindex.
 No
contexto automobilÃ­stico, a implementaÃ§Ã£o do sistema  na
UniÃ£o Europeia (obrigatÃ³rio em carros novos desde 2018 conforme Regulamento UE 2015/758 ) representa um
marco em sistemas automÃ¡ticos de chamada de emergÃªncia. O projeto europeu i-VITAL  explorou a extensÃ£o dessa tecnologia para motociclistas, integrando monitoramento de sinais vitais em capacetes e vestimentas. O 
utiliza sensores de impacto do veÃ­culo e, em caso de colisÃ£o grave,
disca automaticamente para o nÃºmero de emergÃªncia 112, transmitindo
dados bÃ¡sicos como localizaÃ§Ã£o e hora do acidente. Estudos europeus
estimam que sistemas desse tipo podem reduzir o tempo de resposta dos
socorristas em atÃ© 50\%, especialmente em Ã¡reas rurais.
Inspirados nesse conceito, fabricantes tÃªm desenvolvido soluÃ§Ãµes para
motos: por exemplo, a Bosch lanÃ§ou em 2020 o serviÃ§o Help
Connect, que usa o sensor de aceleraÃ§Ã£o do mÃ³dulo ABS de motocicletas e
o smartphone do piloto para detectar quedas e acionar uma central de
emergÃªncia da prÃ³pria Bosch. Nos Estados Unidos,
sistemas como o OnStar (da GM) e o SiriusXM Guardian tambÃ©m passaram a
incluir detecÃ§Ã£o de acidente e chamada de emergÃªncia automÃ¡tica, mas
focados em carros. Para motos, uma dificuldade adicional estÃ¡ em
diferenciar um acidente de situaÃ§Ãµes corriqueiras como a moto tombada
ao estacionar. Abordagens comerciais contornam isso combinando sensores
e solicitando confirmaÃ§Ã£o do usuÃ¡rio. Nosso projeto bebe dessa fonte no
sentido de adotar notificaÃ§Ã£o automÃ¡tica via smartphone, porÃ©m busca uma
soluÃ§Ã£o de baixo custo e independente de fabricantes de veÃ­culos.
Diversos estudos exploraram o uso de smartphones para detectar acidentes
de trÃ¢nsito. O sistema , desenvolvido por White  ,
foi um dos pioneiros, utilizando o acelerÃ´metro e GPS do telefone para
identificar colisÃµes e enviar alertas geolocalizados.
Uma vantagem de usar o smartphone Ã© aproveitar sensores e conectividade
jÃ¡ disponÃ­veis; no entanto, hÃ¡ pontos negativos: o aparelho pode nÃ£o
estar fixo de forma ideal atenuando ou distorcendo mediÃ§Ãµes, e apps
precisam rodar continuamente podendo ser encerrados pelo sistema para
poupar bateria. O sistema , proposto por Aloul  , introduziu o uso de Dynamic Time Warping (DTW) para distinguir padrÃµes de colisÃ£o de movimentos normais. Para motocicletas especificamente, o sistema , analisado por Hannan, Yadav e Yadav , demonstra que um pequeno conjunto de sensores bem integrados Ã© suficiente para reduzir significativamente o tempo entre o acidente e o acionamento de ajuda. Esses projetos combinam limiares de aceleraÃ§Ã£o (tipicamente ~3) com detecÃ§Ã£o de
silÃªncio abrupto (microfone) para aumentar confiabilidade. Atualmente,
grandes empresas incorporaram tais funcionalidades: iPhones e relÃ³gios
Apple modernos possuem o , capaz de discar para
emergÃªncia se detectarem um acidente severo. Esse recurso de detecÃ§Ã£o de
acidentes do Apple Watch foi inclusive citado em
reportagens por ter salvo vidas em alguns casos. O Google Pixel tambÃ©m
conta com funÃ§Ã£o similar. Tais soluÃ§Ãµes embarcadas nos smartphones sÃ£o
importantes para difundir a ideia de chamada automÃ¡tica; contudo, Ã©
necessÃ¡rio que o usuÃ¡rio possua um modelo especÃ­fico de aparelho e
esteja com ele consigo e ligado. No nosso projeto, optamos por um
dispositivo dedicado na moto, que nÃ£o depende do usuÃ¡rio carregar um
telefone de Ãºltima geraÃ§Ã£o e pode, inclusive, ser transferido entre
motos.
 A
identificaÃ§Ã£o de placas de veÃ­culos atravÃ©s de visÃ£o computacional Ã© um
problema clÃ¡ssico, com soluÃ§Ãµes consolidadas conhecidas como LPR
(). Em muitos paÃ­ses, hÃ¡ sistemas de
pedÃ¡gio e vigilÃ¢ncia que fotografam placas e reconhecem automaticamente
os caracteres. Para nosso caso de uso em acidentes, o desafio Ã© realizar
isso em um dispositivo mÃ³vel, possivelmente com imagens nÃ£o ideais
devido a Ã¢ngulo e iluminaÃ§Ã£o. Abordagens modernas empregam algoritmos de
detecÃ§Ã£o como o YOLO para localizar a placa na imagem, seguido de um OCR
para leitura. Trabalhos recentes como o de Siam   prop\~oem sistemas similares integrando detec\~ao de acidentes com monitoramento de sinais fisiol\'ogicos para motocicletas, enquanto Karuna   demonstram a viabilidade de sistemas IoT para detec\~ao de quedas de motocicletas. especificamente, Montazzolli e Jung  desenvolveram um sistema de detecÃ§Ã£o e reconhecimento em tempo real usando redes neurais convolucionais profundas, enquanto Ribeiro   propuseram o uso de dados sintÃ©ticos para treinar detectores de placas Mercosul. Em nosso projeto, utilizamos um modelo YOLO prÃ©-treinado
para objetos genÃ©ricos (que inclui classe â€œplaca de carroâ€) e nos
valemos do framework , da Apple, para OCR de placas
brasileiras (tanto padrÃ£o antigo quanto Mercosul). Ajustes finos foram
necessÃ¡rios, como configurar o  do Vision
para modo  e lÃ­ngua â€œpt-BRâ€ (evitando autocorreÃ§Ã£o de
texto que prejudicava o OCR de placas, jÃ¡ que sequÃªncias alfanumÃ©ricas
nÃ£o formam palavras) e verificar se era viÃ¡vel rodar um modelo YOLO
inteiro no smartphone em tempo hÃ¡bil. Felizmente, os modelos da famÃ­lia
YOLO recentes sÃ£o eficientes, com nossa experiÃªncia indicando tempo de
inferÃªncia tipicamente menor que 0,5 s por foto em resoluÃ§Ã£o 1280x720, e a
qualidade das imagens. Verificou-se que, apesar do movimento e possÃ­veis
tremores na captura, era possÃ­vel extrair quadros nÃ­tidos suficientes do
vÃ­deo do acidente para realizar a leitura.
Algumas outras tecnologias e tendÃªncias merecem menÃ§Ã£o por se relacionarem ao projeto. No Ã¢mbito das redes veiculares V2X, conexÃµes diretas entre veÃ­culos e infraestrutura poderiam, no futuro, permitir que a prÃ³pria motocicleta notificasse veÃ­culos prÃ³ximos ou sistemas de trÃ¡fego sobre um acidente. Embora nosso projeto nÃ£o aborde V2X diretamente, ele foi concebido de forma a poder integrar-se a uma rede dessa natureza, por exemplo enviando o alerta tambÃ©m a um sistema integrado de trÃ¢nsito.
No que tange Ã  seguranÃ§a e privacidade de dados, considera-se importante assegurar que os dados coletados, como imagens e localizaÃ§Ã£o, sejam utilizados apenas para a finalidade de emergÃªncia. Em nossa implementaÃ§Ã£o, os vÃ­deos sÃ£o armazenados em um banco seguro Supabase e as mensagens trafegam criptografadas via APIs. Em uma aplicaÃ§Ã£o comercial, camadas adicionais de seguranÃ§a seriam necessÃ¡rias, como criptografia ponta-a-ponta das evidÃªncias enviadas.
Quanto Ã  normatizaÃ§Ã£o e regulamentaÃ§Ã£o, para que um sistema como este tivesse adoÃ§Ã£o ampla, questÃµes regulatÃ³rias deveriam ser consideradas. Na UniÃ£o Europeia, discute-se estender o eCall para motocicletas, conforme previsto no Regulamento (UE) 2015/758 . No Brasil, nÃ£o hÃ¡ exigÃªncia legal ainda, mas Ã³rgÃ£os como o CONTRAN poderiam vir a recomendar ou padronizar dispositivos de chamado de emergÃªncia em veÃ­culos de duas rodas, dada a magnitude do problema. Este trabalho, ao demonstrar viabilidade tÃ©cnica, serve tambÃ©m como subsÃ­dio para futuras normas.
Em suma, o estado da arte mostra que os elementos necessÃ¡rios para o
Projeto Vindex jÃ¡ existem de forma isolada: sensores eficientes,
algoritmos de detecÃ§Ã£o de padrÃµes, comunicaÃ§Ã£o rÃ¡pida e ferramentas de
visÃ£o computacional. O diferencial proposto estÃ¡ na convergÃªncia desses
elementos em um dispositivo Ãºnico de baixo custo, otimizado para
motocicletas, e na profundidade da integraÃ§Ã£o entre hardware embarcado,
aplicativo mÃ³vel e serviÃ§os de nuvem para entregar uma soluÃ§Ã£o completa
de alerta de acidente.
% Materiais e MÃ©todos
Neste capÃ­tulo sÃ£o apresentados os componentes de hardware e software
utilizados (materiais), bem como os mÃ©todos e estratÃ©gias de
desenvolvimento empregados para construir e validar o sistema proposto.
A abordagem metodolÃ³gica seguiu um ciclo iterativo de projeto,
prototipagem, teste e refinamento, conforme serÃ¡ evidenciado na seÃ§Ã£o de
evoluÃ§Ã£o do projeto ().
  A fase inicial do
trabalho consistiu na  (PoC), cujo objetivo
foi verificar a viabilidade tÃ©cnica fundamental antes de partir para a construÃ§Ã£o do protÃ³tipo integrado. Nessa etapa, buscou-se validar os principais riscos tÃ©cnicos: capacidade dos sensores de detectar eventos crÃ­ticos de forma confiÃ¡vel, viabilidade de acionar e operar a cÃ¢mera transmitindo imagens em tempo adequado, e funcionamento da comunicaÃ§Ã£o entre dispositivos (ESP32, Raspberry Pi e smartphone) com transferÃªncia correta de dados.
Para isso, a PoC foi realizada inicialmente sem a montagem fÃ­sica definitiva, utilizando os mÃ³dulos em bancada para validaÃ§Ã£o individual de cada componente.
Os resultados da PoC foram animadores: o sensor inercial mostrava picos claros de aceleraÃ§Ã£o e variaÃ§Ãµes de giro nas simulaÃ§Ãµes de acidente, a cÃ¢mera do Raspberry Pi capturava imagens rapidamente, e o BLE permitiu
transferir uma foto de resoluÃ§Ã£o VGA em poucos segundos para o
smartphone. Aprendemos, contudo, que seria necessÃ¡rio otimizar alguns
pontos como a transferÃªncia via BLE de uma imagem 
de 50 kB que demorava vÃ¡rios segundos, indicando que compressÃ£o ou resoluÃ§Ã£o
menor seriam importantes. TambÃ©m constatamos a necessidade de um
 para envio das notificaÃ§Ãµes, dada a dificuldade de o
app iOS disparar mensagens por conta prÃ³pria devido a problemas com
bibliotecas do Telegram. Essas liÃ§Ãµes foram incorporadas na etapa
seguinte de desenvolvimento do protÃ³tipo completo.
O desenvolvimento do Projeto Vindex seguiu um processo iterativo com mÃºltiplas fases de prototipagem, cada qual revelando limitaÃ§Ãµes tÃ©cnicas que motivaram mudanÃ§as significativas na arquitetura. A documentaÃ§Ã£o transparente dessas fases Ã© fundamental para justificar as decisÃµes finais de projeto, demonstrando que a soluÃ§Ã£o adotada nÃ£o foi arbitrÃ¡ria, mas sim resultado de experimentaÃ§Ã£o sistemÃ¡tica e aprendizado com falhas. Conforme destacam Gelmini, Panzani e Savaresi , o desenvolvimento de sistemas de eCall para motocicletas apresenta desafios especÃ­ficos que exigem abordagens adaptativas.
O trabalho iniciou-se em agosto com a tentativa de integrar a biblioteca TDLib (Telegram Database Library) ao ambiente Xcode para desenvolvimento iOS. O objetivo era permitir que o aplicativo Vindex enviasse mensagens de alerta diretamente atravÃ©s do Telegram, sem intermediÃ¡rios. Contudo, essa abordagem revelou-se um fracasso tÃ©cnico significativo.
A biblioteca TDLib apresentou inÃºmeras incompatibilidades com o ambiente de desenvolvimento Xcode, incluindo problemas de compilaÃ§Ã£o, conflitos de dependÃªncias e erros persistentes de linkagem. ApÃ³s aproximadamente trÃªs semanas de tentativas, incluindo consultas a fÃ³runs especializados como o StackOverflow, a integraÃ§Ã£o nÃ£o foi possÃ­vel. A razÃ£o fundamental reside nas diretrizes de privacidade dos sistemas operacionais mÃ³veis: tanto iOS quanto Android proÃ­bem o envio automÃ¡tico de mensagens por aplicativos de terceiros atravÃ©s de serviÃ§os como Telegram, WhatsApp ou SMS, sem intervenÃ§Ã£o explÃ­cita do usuÃ¡rio. Uma soluÃ§Ã£o alternativa seria incorporar o prÃ³prio Telegram como mÃ³dulo dentro do aplicativo Vindex, mas essa abordagem foi abandonada devido Ã  sua complexidade e aos erros persistentes.
Diante do fracasso da Fase I, desenvolveu-se uma soluÃ§Ã£o alternativa baseada em um bot do Telegram denominado ``Alertas Vindex''. O sistema foi projetado para ser o mais simples possÃ­vel do ponto de vista do usuÃ¡rio final: o motorista gera um cÃ³digo de pareamento no aplicativo; o contato guardiÃ£o procura o bot @Vindex no Telegram e informa esse cÃ³digo; instantaneamente, o Telegram fica vinculado como contato de emergÃªncia.
Essa arquitetura utiliza o banco de dados Supabase como intermediÃ¡rio. Quando o aplicativo detecta um acidente, ele notifica o backend no Supabase, que por sua vez aciona o bot para enviar o alerta ao guardiÃ£o. Essa soluÃ§Ã£o contornou elegantemente as restriÃ§Ãµes do iOS quanto a notificaÃ§Ãµes push em aplicativos em desenvolvimento, que exigiriam uma conta de desenvolvedor paga de 99 dÃ³lares anuais com processo burocrÃ¡tico complexo para ativaÃ§Ã£o em moeda brasileira.
A fase seguinte, em outubro, concentrou-se na comunicaÃ§Ã£o entre o hardware embarcado e o aplicativo mÃ³vel, revelando problemas crÃ­ticos com o Raspberry Pi e o protocolo Bluetooth. Mesmo operando em modo headless (sem interface grÃ¡fica), o Raspberry Pi Zero 2W apresentou limitaÃ§Ãµes severas na comunicaÃ§Ã£o via Bluetooth Low Energy (BLE).
O primeiro problema identificado foi o tempo de inicializaÃ§Ã£o: o RPi levava aproximadamente 15 segundos para ser ``acordado'' pelo nodeMCU (ESP32) em simulaÃ§Ãµes de acidente. Em um contexto real, veÃ­culos envolvidos jÃ¡ estariam a muitos metros de distÃ¢ncia nesse intervalo. Tentativas de refinamento de software nÃ£o conseguiram reduzir significativamente esse tempo de boot.
O segundo problema, mais grave, relacionava-se Ã  instabilidade da conexÃ£o Bluetooth do Raspberry Pi. ApÃ³s mÃºltiplas tentativas com diferentes bibliotecas Python, incluindo ,  e , nenhuma delas conseguiu manter uma conexÃ£o ativa com o aplicativo iOS em segundo plano. Esse problema Ã© amplamente documentado na comunidade de desenvolvimento iOS: o CoreBluetooth impÃµe restriÃ§Ãµes significativas quando o aplicativo estÃ¡ em background e o dispositivo bloqueado, nÃ£o invocando callbacks para dispositivos nÃ£o pareados ou sem CBUUIDs especÃ­ficos configurados. Ao minimizar o aplicativo, a conexÃ£o entre hardware e software era instantaneamente eliminada, impossibilitando o envio de evidÃªncias quando o smartphone estivesse com a tela bloqueada. Conforme documentado pela Apple, o  Ã© ignorado em background, coalescendo mÃºltiplas descobertas em um Ãºnico evento. Esse comportamento nÃ£o ocorria com o nodeMCU ESP32, que mantinha o monitoramento constante mesmo com o aplicativo em segundo plano devido ao seu suporte nativo mais robusto para BLE 5.0 e implementaÃ§Ã£o de GATT server otimizada.
Com o treinamento da rede neural YOLO concluÃ­do (utilizando um dataset de aproximadamente 4.000 imagens de placas padrÃ£o MERCOSUL e modelo antigo, com data augmentation para diversos Ã¢ngulos e condiÃ§Ãµes), partiu-se para testes alternativos de hardware. Inicialmente, o ESP32-CAM apresentou resultados promissores: conexÃ£o estÃ¡vel, funcionamento em segundo plano e envio rÃ¡pido de imagens para o aplicativo, onde o processamento com YOLO, OpenCV e OCR era executado.
Entretanto, constatou-se que imagens estÃ¡ticas, mesmo em modo burst, nÃ£o capturavam adequadamente o contexto dinÃ¢mico de um acidente. Se o dispositivo fosse utilizado em movimento, mesmo a sequÃªncia de fotos nÃ£o forneceria imagens adequadas para anÃ¡lise devido ao blur causado pela velocidade do veÃ­culo.
Consequentemente, cogitou-se a troca para o ESP32-S3 com cÃ¢mera OV5647 de 5MP, visando implementar um buffer circular de vÃ­deo de aproximadamente 5 segundos. A ideia era captar o acidente antes, durante e apÃ³s o evento. Contudo, as limitaÃ§Ãµes de memÃ³ria do ESP32-S3 (8 MB de PSRAM total) impediram essa abordagem: com qualidade mÃ­nima aceitÃ¡vel para OCR (640x480), era possÃ­vel armazenar apenas 5 segundos de vÃ­deo a 2 frames por segundo, resultando em qualidade insuficiente para reconhecimento de placas. Formatos alternativos como RAW, RGB565 e YUV422 foram testados sem sucesso, uma vez que o ESP32-S3 nÃ£o possui poder computacional para executar um encoder de vÃ­deo.
A partir das liÃ§Ãµes aprendidas, ficou claro que seria necessÃ¡rio retornar ao Raspberry Pi como Ãºnico hardware capaz de gravar vÃ­deo em buffer circular com qualidade suficiente para processamento OCR. O RPi opera com encoder H.264 nativo e tem capacidade de converter para MP4, gerando arquivos compactos adequados para anÃ¡lise rÃ¡pida.
Devido Ã s limitaÃ§Ãµes de transferÃªncia via Bluetooth do RPi (velocidade mÃ¡xima de aproximadamente 45 KB/s via BLE, com frequentes perdas de pacotes, corrupÃ§Ã£o de dados e travamentos), e Ã  impossibilidade de usar modo dual-mode (BLE + Bluetooth ClÃ¡ssico) devido Ã s restriÃ§Ãµes MFi (Made for iPhone) da Apple, foi necessÃ¡rio repensar completamente o fluxo de dados.
A soluÃ§Ã£o adotada utiliza o Supabase nÃ£o apenas para alertas, mas tambÃ©m para armazenamento de evidÃªncias em vÃ­deo. O fluxo final funciona da seguinte forma: o ESP32-C3 monitora continuamente o acelerÃ´metro e giroscÃ³pio; ao detectar um acidente, com um delay de 5 segundos, sinaliza ao RPi para salvar os Ãºltimos 8 segundos do buffer circular; o RPi converte o vÃ­deo para MP4 e faz upload para a nuvem; ao concluir o upload, o RPi notifica o ESP32-C3, que informa ao aplicativo que o vÃ­deo estÃ¡ disponÃ­vel. O usuÃ¡rio entÃ£o pode baixar o vÃ­deo da nuvem e o processamento de visÃ£o computacional inicia automaticamente.
Esse fluxo completo leva aproximadamente 2 minutos ou menos. O vÃ­deo comprimido Ã© enviado em qualidade 720p a 25 quadros por segundo, com tamanho aproximado de 3,5 MB, irrisÃ³rio para conexÃµes de internet modernas e suficiente para que o OCR reconheÃ§a placas de veÃ­culos com precisÃ£o aceitÃ¡vel.
AlÃ©m da detecÃ§Ã£o de acidentes, o sistema implementa funcionalidade de telemetria para monitoramento contÃ­nuo do comportamento do condutor. Conforme demonstrado por Mantouka  , sensores de smartphones sÃ£o uma plataforma madura para coleta de dados telemÃ©tricos, com aplicaÃ§Ãµes em seguranÃ§a viÃ¡ria e seguros baseados em uso. A telemetria do Vindex coleta dados de aceleraÃ§Ã£o, frenagem e velocidade, gerando um score de qualidade de pilotagem que pode ser Ãºtil para empregadores de motociclistas ou companhias de seguros. Esses dados sÃ£o armazenados de forma que nÃ£o podem ser apagados pelo usuÃ¡rio, garantindo integridade para anÃ¡lises posteriores. O aplicativo exibe estatÃ­sticas por viagem, incluindo um heatmap do trajeto indicando trechos onde a velocidade excedeu os limites urbanos.
  Com a
prova de conceito validada e as liÃ§Ãµes das fases evolutivas incorporadas, partimos para projetar a arquitetura
integrada do sistema Vindex. A arquitetura, ilustrada na Figura
, pode ser entendida em trÃªs camadas principais:
 na motocicleta,  do
usuÃ¡rio e  de suporte.
    % Coluna esquerda: Hardware embarcado
     (imu)
      \\^ometro + Girosc\'opio;
     (esp)
      \ sensor\ acidentes;
     (rpi)
      \ v\'ideo\ nuvem;
     (cam)
      \\160Â° FOV, 720p H.264;
     (bat)
      \\3.7V + Conversor 5V;
    % Coluna direita: Smartphone e Nuvem
     (phone)
      \ Vindex\ + GPS;
     (cloud)
      \\ Telegram;
    % Conex\~oes verticais (hardware)
     (imu) -- node[right] I2C (esp);
     (esp) -- node[right] GPIO (rpi);
     (rpi) -- node[right] CSI (cam);
     (cam) -- (bat);
    % Conex\~oes em L da bateria para componentes
     (bat.east) -| ([xshift=0.5cm]esp.east);
     (bat.east) -| ([xshift=0.5cm]rpi.east);
    % Conex\~oes em U do ESP32 para smartphone (BLE)
     (esp.east) -- ++(1.5cm,0) |- node[pos=0.25, above] BLE (phone.west);
    % Conex\~ao em U do RPi para smartphone (Wi-Fi)
     (rpi.east) -- ++(2cm,0) |- node[pos=0.25, above] Wi-Fi (phone.west);
    % Conex\~ao smartphone para nuvem
     (phone) -- node[right] API (cloud);
No  (parte esquerda da figura), o sensor
inercial BMI160 monitora continuamente os movimentos da motocicleta,
conectado via interface I2C ao microcontrolador ESP32-C3. Este
microcontrolador fica em modo de baixo consumo, lendo os dados do sensor
e executando o algoritmo de detecÃ§Ã£o de acidentes localmente. Caso
detecte um evento crÃ­tico, ele envia um pulso elÃ©trico em um pino GPIO
para acordar o Raspberry Pi Zero 2W (que permanece em 
para poupar energia). Em seguida, o ESP32-C3 inicia a comunicaÃ§Ã£o
Bluetooth com o smartphone do usuÃ¡rio.
O  (centro) atua quando despertado,
controlando a cÃ¢mera e gerenciando registros de vÃ­deo/imagem. Uma vez
acordado, o RPi salva os instantes relevantes: no protÃ³tipo, optou-se
por gravar aproximadamente 8 segundos de vÃ­deo (os 5 segundos anteriores
e 3 segundos posteriores ao acidente, graÃ§as a um 
circular mantido em memÃ³ria). O Raspberry entÃ£o comprime o vÃ­deo e
inicia seu upload para um serviÃ§o em nuvem (quando possÃ­vel). Em
paralelo, pode capturar uma foto estÃ¡tica para envio rÃ¡pido via BLE ao
app.
No  do usuÃ¡rio (parte direita), um aplicativo iOS
dedicado permanece em segundo plano conectado ao dispositivo via BLE. Ao
receber do ESP32-C3 o sinal de que um acidente foi detectado, o app
imediatamente busca obter a localizaÃ§Ã£o GPS atual e apresenta ao usuÃ¡rio
um alerta sonoro/visual, conforme RF-07. Se o usuÃ¡rio nÃ£o cancelar
dentro do tempo estipulado (p.ex., 15 segundos), o app prossegue para
notificar os contatos de emergÃªncia. Para tal, ele compila uma mensagem
contendo as informaÃ§Ãµes do acidente (coordenadas, hora, possivelmente a
foto com destaque da placa detectada) e envia a um serviÃ§o
 na nuvem.
Os  (parte inferior) englobam um banco de
dados e armazenamento de mÃ­dia (vÃ­deos/imagens) mantidos em um servidor
remoto (no protÃ³tipo, utilizou-se a plataforma Supabase). Quando o app
envia os dados do acidente para a nuvem, um  no banco
aciona a API de um bot do Telegram, que por sua vez encaminha a
notificaÃ§Ã£o final aos contatos prÃ©-configurados (no caso, um â€œGuardiÃ£oâ€
escolhido pelo motociclista). Essa arquitetura, embora ligeiramente mais
complexa do que um envio direto via SMS, trouxe vantagens: permitiu
anexar um link para o vÃ­deo do acidente (armazenado no servidor) e
contornou limitaÃ§Ãµes de envio automÃ¡tico impostas pelo iOS. AlÃ©m disso,
manteve um registro persistente de todos os incidentes para posterior
anÃ¡lise.
Nos prÃ³ximos tÃ³picos, detalhamos cada subsistema, desde os componentes
de hardware utilizados atÃ© as soluÃ§Ãµes de software implementadas, bem
como as estratÃ©gias de teste e validaÃ§Ã£o empregadas em cada etapa.
Descrevemos os principais mÃ³dulos de hardware do~protÃ³tipo, justificando as~escolhas e~apresentando parÃ¢metros de~configuraÃ§Ã£o.
O ESP32-C3 Super Mini constitui o nÃºcleo de processamento embarcado do sistema Vindex. Este microcontrolador, fabricado pela Espressif Systems, baseia-se em arquitetura RISC-V de 32 bits com clock de 160 MHz, oferecendo desempenho computacional robusto para processamento em tempo real dos dados sensoriais. As dimens\~oes ultracompactas de 22,52 x 18 mm permitem integra\~ao discreta na estrutura da motocicleta.
\~oes de MemÃ³ria: O dispositivo integra 400 KB de SRAM on-chip para execu\~ao de cÃ³digo e buffers de dados, com 16 KB dedicados para cache de instru\~oes. A memÃ³ria flash SPI externa de 4 MB opera a 80 MHz em modo Quad-SPI, permitindo acesso rÃ¡pido ao firmware. A parti\~ao foi otimizada com 1 MB para firmware, 512 KB para OTA, 256 KB para NVS e 2,25 MB para SPIFFS.
 Em modo deep sleep consome apenas 5 A com RTC ativo. Durante opera\~ao normal com BLE ativo, o consumo mÃ©dio Ã© de 78 mA a 3,3V. O modo light sleep reduz o consumo para 1,8 mA mantendo conex\~ao BLE.
 O transceptor RF integrado suporta BLE 5.0 com Long Range e pot\^encia de -12 a +9 dBm. Sensibilidade de -94 dBm a 1 Mbps garante conex\~ao estÃ¡vel. O stack NimBLE ocupa apenas 42 KB de RAM. Antena PCB integrada com ganho de 2,1 dBi.
 I2C a 400 kHz para BMI160 (GPIO 21/22), GPIO 4 para wake-up do RPi, GPIOs 8/9 para LEDs via PWM 5 kHz, UART debug a 115200 baud (GPIO 1/3)
e Wi-Fi 2.4~GHz integradas. Escolhemos este chip (na
forma de um mÃ³dulo â€œSuper Miniâ€ compacto de 18~mm x 25~mm) para ser o
 devido a seu baixÃ­ssimo consumo em modo de espera e
capacidade de monitoramento contÃ­nuo do acelerÃ´metro/giroscÃ³pio
praticamente sem drenar a bateria. Alguns pontos crÃ­ticos pesaram na
decisÃ£o:   : Permite
comunicaÃ§Ã£o direta com o app mÃ³vel sem hardware adicional, atendendo
RF-04 e RNF-06. A versÃ£o 5.0 do BLE suportada oferece maior alcance e
pacote de dados mais extensos que versÃµes anteriores, o que Ã© Ãºtil para
transmitir eventuais imagens pequenas.  Baixo consumo e
modo Deep Sleep: O ESP32-C3 pode operar em modo 
consumindo na ordem de poucos microampÃ¨res, mantendo apenas o RTC ativo
para despertar periodicamente ou por interrupÃ§Ã£o externa. Isso foi
essencial para cumprir RNF-01 de autonomia.  Suporte a
perifÃ©ricos e DMA: A necessidade de ler o sensor inercial a alta taxa
(100 Hz ou mais) e eventualmente repassar dados ao Raspberry Pi requer
capacidade de comunicaÃ§Ã£o I2C/UART eficiente. O ESP32-C3 possui
controladores I2C dedicados e pode utilizar DMA para minimizar
latÃªncias, garantindo desempenho em tempo real para detecÃ§Ã£o.
No protÃ³tipo, utilizamos o ESP32-C3 rodando um firmware em C++ (usando a
estrutura do ESP-IDF/Arduino) dividido em tarefas FreeRTOS: uma tarefa
de leitura de sensores e detecÃ§Ã£o, rodando a cada 10 ms, e uma tarefa de
comunicaÃ§Ã£o BLE para envio de dados. Optamos por um algoritmo de
detecÃ§Ã£o simples baseado em limiar de aceleraÃ§Ã£o resultante e variaÃ§Ã£o
de Ã¢ngulo (integral do giroscÃ³pio). Ao detectar um possÃ­vel acidente, o
ESP32 aciona imediatamente a linha de  do Raspberry Pi
(saÃ­da GPIO conectada a um pino de  do Pi configurado
para esse propÃ³sito) e entÃ£o inicia o procedimento de notificaÃ§Ã£o: envia
via BLE um pacote sinalizando â€œacidente detectadoâ€ para o app e comeÃ§a a
transmitir dados bÃ¡sicos (valor de pico de , por exemplo).
Importante notar que o ESP32-C3 tambÃ©m monitorou a conexÃ£o BLE
continuamente para transmitir dados de telemetria durante o uso normal.
Isso permitiu implementar funÃ§Ãµes adicionais como indicar nÃ­vel de
bateria no app e atÃ© gerar um log de pilotagem. Entretanto, tais
funcionalidades extras ficaram como provas de conceito e nÃ£o sÃ£o foco do
escopo principal.
 Este mÃ³dulo integra o sensor de
movimento Bosch BMI160, que combina um acelerÃ´metro triaxial e
um giroscÃ³pio triaxial no mesmo chip. Esse sensor foi escolhido por ser
amplamente utilizado e bem documentado, com consumo
baixo (aprox. 925~A em acelerÃ´metro + giroscÃ³pio a 100 Hz) e range
ajustÃ¡vel atÃ©  (acelerÃ´metro) e 
(giroscÃ³pio). CaracterÃ­sticas relevantes:
  O BMI160 foi configurado com faixa de $
16g 2000^/s$ para giro, e taxa de
amostragem de 1600 Hz internamente, fazendo  para
entregar dados filtrados a 100 Hz ao microcontrolador. Esse
 ajuda a reduzir ruÃ­do.  Usamos o recurso de
 embutido: o BMI160 possui um mÃ³dulo
interno capaz de detectar movimento significativo ou queda livre.
Entretanto, preferimos aplicar nossos prÃ³prios critÃ©rios no firmware
para melhor controle, mas mantivemos o sensor configurado para sinalizar
interrupÃ§Ã£o de â€œqueda livreâ€ (queda livre detectada quando
 abaixo de 0.5 por > 30 ms, como quando a moto decola
em um salto ou o sensor perde suporte). Esse sinal de interrupÃ§Ã£o foi
disponibilizado no ESP32, porÃ©m nos testes raramente diferenciou cenÃ¡rio
alÃ©m do que jÃ¡ detectÃ¡vamos via picos e giros.  A calibraÃ§Ã£o do
giroscÃ³pio foi fundamental: implementamos no ESP32 que, se a moto
permanecer parada (aceleraÃ§Ãµes muito baixas) por pelo menos 5 segundos,
Ã© disparado o comando de  do BMI160 para
zerar viÃ©s do giroscÃ³pio naquela orientaÃ§Ã£o. Isso
ocorre tipicamente pouco depois de ligar o sistema, quando a moto estÃ¡
estacionada, garantindo que o Ã¢ngulo integrado do giroscÃ³pio comece
referenciado apropriadamente.  O sensor foi fisicamente posicionado
prÃ³ximo ao centro de gravidade da motocicleta (no protÃ³tipo, fixado na
placa de circuito o mais central possÃ­vel). Isso reduz efeitos de
aceleraÃ§Ãµes rotacionais se o sensor ficasse em uma extremidade.
Durante os testes, o BMI160 mostrou-se suficientemente sensÃ­vel e
confiÃ¡vel. SimulaÃ§Ãµes manuais de quedas (movimentar rapidamente a placa
do sensor e parar abruptamente) produziram picos claros de aceleraÃ§Ã£o
nas leituras, facilmente distinguÃ­veis de vibraÃ§Ãµes normais do motor.
Observou-se tambÃ©m a importÃ¢ncia de filtrar ruÃ­dos: implementamos um
filtro passa-baixas no cÃ³digo para separar a componente estÃ¡tica
(gravidade) da dinÃ¢mica: subtrair a mÃ©dia mÃ³vel das leituras permitiu
destacar apenas mudanÃ§as bruscas. Esse processamento simples foi
executado no ESP32 sem dificuldades.
 O Raspberry Pi Zero
2 W atua como  mais
pesado. Suas especificaÃ§Ãµes (CPU Broadcom quad-core ARM Cortex-A53 1.0
GHz, 512 MB RAM, Bluetooth 4.2, Wi-Fi b/g/n) permitem rodar um sistema
operacional Linux e executar tarefas que seriam inviÃ¡veis no
microcontrolador, como tratamento de imagem e conexÃ£o com serviÃ§os web.
Escolhemos este modelo por equilibrar baixo consumo e tamanho reduzido
com capacidade de rodar algoritmos de visÃ£o e aplicativos de rede.
Alternativas consideradas incluÃ­ram o Raspberry Pi 3A+ (mais potente,
porÃ©m maior e de consumo maior) e mÃ³dulos microcontroladores com cÃ¢mera
(ESP32-CAM, ESP32-S3 Eye), mas concluÃ­mos que a confiabilidade na
gravaÃ§Ã£o de vÃ­deo e upload exigia um sistema operacional robusto. Assim,
o RPi Zero 2 W integra a arquitetura final, mantendo-se inativo na maior
parte do tempo (modo /espera) e entrando em aÃ§Ã£o apenas
quando necessÃ¡rio.
Para otimizar o uso do Raspberry e cumprir RNF-01:  
: Configuramos o RPi para iniciar em
 somente quando alimentado por uma linha de 5V controlada
pelo ESP32 (via um transistor MOSFET atuando como chave). Ou seja, no
estado normal, o ESP32 nÃ£o alimenta o Pi, poupando a bateria; ao
detectar um acidente, o ESP32 libera a alimentaÃ§Ã£o e aciona o boot do
Pi. Essa estratÃ©gia, implementada no protÃ³tipo final de forma
simplificada (o Pi era ligado junto com todo o sistema, mas em futuras
versÃµes seria ligado sob demanda), garante que o consumo elevado do
Raspberry nÃ£o interfira na autonomia exceto nos momentos crÃ­ticos. 
: No Raspberry Pi OS removemos serviÃ§os
desnecessÃ¡rios, desabilitamos interface grÃ¡fica e atÃ© desligamos saÃ­das
de status (como LED e HDMI) para reduzir consumo e acelerar a
inicializaÃ§Ã£o. Com isso, o tempo de boot do Pi desde o acionamento atÃ©
estar pronto para capturar vÃ­deo ficou em torno de 6--8 segundos. 
: Implementamos, em Python (usando a
biblioteca Picamera2), um buffer circular que mantÃ©m na memÃ³ria os
frames recentes da cÃ¢mera. A cÃ¢mera fica ligada gravando em baixa
resoluÃ§Ã£o continuamente, mas descartando frames antigos. Quando o ESP32
sinaliza um acidente, um script salva em arquivo os Ãºltimos segundos do
buffer (por exemplo, 5 s anteriores) e continua gravando por mais alguns
segundos (3 s) para pegar o desfecho.  :
Logo apÃ³s salvar o vÃ­deo (em formato H.264, 720p), o Raspberry Pi inicia
o upload para o servidor na nuvem via Wi-Fi do smartphone (usando
tethering do iPhone conectado por BLE, que habilita temporariamente o
hotspot). Para enviar ~3 MB de vÃ­deo, medimos cerca de 5--6 segundos em
rede 4G, considerado aceitÃ¡vel. Caso o upload demore ou nÃ£o haja
conexÃ£o, o vÃ­deo fica armazenado localmente e o app smartphone tenta
reenviar mais tarde. 
Nos testes, o Raspberry Pi cumpriu seu papel, embora seu consumo seja
significativo: medimos ~200 mA em idle e picos de 500--600 mA durante
compressÃ£o e upload de vÃ­deo. Por isso, reforÃ§a-se que mantÃª-lo
desligado quando possÃ­vel Ã© crucial. O protÃ³tipo final nÃ£o implementou
hardware para desligar completamente o Pi (devido a limitaÃ§Ãµes de
tempo), mas tal melhoria estÃ¡ documentada para trabalhos futuros.
 Para a coleta de evidÃªncias
visuais, utilizamos uma cÃ¢mera compatÃ­vel com o Raspberry Pi baseada no
sensor OmniVision OV5647 de 5 Megapixels (a mesma especificaÃ§Ã£o da
cÃ¢mera oficial Pi v1). Escolhemos acoplar a essa cÃ¢mera uma lente do
tipo  de 160Â° de campo de visÃ£o, ampliando
significativamente o enquadramento. Isso permite cobrir praticamente
toda a frente da moto e boa parte das laterais, garantindo que,
independentemente da direÃ§Ã£o do impacto, haja uma probabilidade alta de
a cÃ¢mera capturar parte da cena.
Configuramos a cÃ¢mera para operar em 1280x720 pixels a 30 FPS durante o
 (resoluÃ§Ã£o suficiente para identificar veÃ­culos e
eventos, mantendo baixo o volume de dados). Ao acionar a gravaÃ§Ã£o,
salvamos o vÃ­deo em H.264 usando aceleraÃ§Ã£o de hardware do Pi (GPU), o
que minimiza o impacto na CPU.
Testes mostraram que mesmo em condiÃ§Ãµes noturnas com iluminaÃ§Ã£o pÃºblica
fraca, a cÃ¢mera conseguia registrar placas refletivas de veÃ­culos
prÃ³ximos graÃ§as ao farol da prÃ³pria moto ou iluminaÃ§Ã£o do ambiente. Em
cenÃ¡rios diurnos, a qualidade foi plenamente satisfatÃ³ria para OCR apÃ³s
correÃ§Ãµes simples (como ajuste de contraste em alguns casos extremos).
A cÃ¢mera foi fixada na parte frontal da carcaÃ§a impressa em 3D, com
Ã¢ngulo levemente inclinado para baixo para capturar tambÃ©m o chÃ£o
prÃ³ximo (Ãºtil para contexto do acidente, como marcas de frenagem ou
obstÃ¡culos).
 O protÃ³tipo utiliza uma bateria de
Ã­ons de lÃ­tio 18650 de 3,7 V (2500 mAh) como fonte de energia, conectada
a um circuito  que provÃª 5 V estÃ¡veis para os
dispositivos (ESP32-C3 e Raspberry Pi). Essa bateria, em teoria, fornece
~9,25 Wh; considerando consumo mÃ©dio de ~0,9 W (ESP32 ~0,1 W + RPi
desligado ~0,05 W + picos esporÃ¡dicos do RPi ativo), a autonomia
estimada Ã© de aproximadamente 10 horas, atendendo RNF-01.
Implementamos monitoramento do nÃ­vel da bateria via um mÃ³dulo inteligente de carregamento de bateria
conectado ao ESP32, permitindo enviar a porcentagem de carga ao
app periodicamente. TambÃ©m previmos um circuito de proteÃ§Ã£o para evitar
descarga profunda, com a bateria se desconectando ao atingir aproximadamente 3,0 V.
No futuro, para uso real, o dispositivo poderia ser ligado Ã  bateria da
moto para recarga, ou incluir um pequeno painel solar no case.
Entretanto, na fase de monografia, optou-se por focar na operaÃ§Ã£o
autÃ´noma com recarga manual diÃ¡ria.
 A implementaÃ§Ã£o em software dividiu-se em trÃªs
frentes: firmware do ESP32-C3, scripts e programas no Raspberry Pi, e
aplicativo iOS. Destacamos particularidades e metodologias
utilizadas em cada qual.
 O firmware do ESP32-C3 foi
desenvolvido em C++ (framework Arduino, pela familiaridade e
disponibilidade de bibliotecas) com algumas otimizaÃ§Ãµes de baixo nÃ­vel.
O cÃ³digo foi estruturado em tarefas FreeRTOS, permitindo concorrÃªncia
entre leitura de sensores e comunicaÃ§Ã£o BLE.
A tarefa de  configura o BMI160 para
amostragem a cada 10 ms (100 Hz). A cada ciclo, lÃª aceleraÃ§Ã£o e
velocidade angular atuais. Aplica-se um filtro exponencial para estimar
a componente de gravidade () e subtrai-la da leitura do
acelerÃ´metro, obtendo a aceleraÃ§Ã£o dinÃ¢mica. Em seguida, calcula-se a
magnitude resultante  e verifica-se:   Se
  se houve uma
mudanÃ§a sÃºbita na orientaÃ§Ã£o detectada via integraÃ§Ã£o do giroscÃ³pio
indicando inclinaÃ§Ã£o superior a 65Â° em qualquer direÃ§Ã£o, entÃ£o sinaliza-se um
potencial acidente.  Caso um potencial acidente seja detectado,
inicia-se um pequeno : aguarda-se 100 ms
para verificar se as leituras se mantÃªm anÃ´malas (picos seguidos de
rÃ¡pida queda a zero, por exemplo, sugerem que a moto parou abruptamente
e tombou). Se confirmado, o firmware muda o estado para â€œacidente
detectadoâ€ e prossegue ao protocolo de alerta. 
No protocolo de alerta, o ESP32-C3 executa:  
: coloca em nÃ­vel alto o pino
conectado ao gate do MOSFET que alimenta o Raspberry, ou envia pulso
conforme circuito configurado.  :
notifica o smartphone via uma caracterÃ­stica BLE de que um acidente
ocorreu, incluindo dados como valor de pico de , lado do impacto
(deduzido do sinal do giroscÃ³pio) e nÃ­vel de bateria atual. 
: o ESP32 espera uma resposta do app
confirmando recebimento. Caso nÃ£o receba (ex.: smartphone desconectado),
tenta reenvio algumas vezes e, se ainda sem sucesso, guarda o evento
numa memÃ³ria flash para tentar entregar posteriormente. 
: apÃ³s enviar o alerta, o ESP32 permanece
acordado por algum tempo para repassar dados complementares. Por
exemplo, conforme o Raspberry Pi fizer upload do vÃ­deo e informar o
link, o ESP32 pode enviar esse link ao app via BLE. 
Adicionalmente, implementamos : quando nÃ£o
hÃ¡ acidente, a cada 1 minuto o ESP32 envia ao app dados como mÃ¡ximas
aceleraÃ§Ãµes registradas e eventuais eventos (por exemplo, â€œfrenagem
brusca em tal localâ€ se assim configurado). Isso pode ser considerado um
â€œprÃ©-alertaâ€ Ãºtil â€“ por exemplo, o guardiÃ£o sabe que algo potencialmente
perigoso ocorreu, mesmo sem ser um acidente. Essa funÃ§Ã£o foi inspirada
pelo funcionamento do recurso de detecÃ§Ã£o de quedas do Apple Watch. Se
ele nÃ£o cancelar, o alerta Ã© enviado findo o tempo.
 O aplicativo mÃ³vel do Projeto Vindex
foi desenvolvido em Swift para iOS, visando inicialmente iPhones (pelo
contexto do autor). As principais funcionalidades do app sÃ£o:
  : O app atua como
 BLE, escaneando pelo dispositivo Vindex e conectando
automaticamente quando detectado. Usamos o modo  do
CoreBluetooth, permitindo que o app receba notificaÃ§Ãµes BLE mesmo
fechado (desde que o usuÃ¡rio tenha pareado o dispositivo previamente).
No Xcode, habilitou-se a opÃ§Ã£o â€œUses Bluetooth LE accessoriesâ€ para que
o iOS mantenha o app ativo em segundo plano.  Recebimento
de alerta: Ao receber do ESP32 a indicaÃ§Ã£o de acidente via
caracterÃ­stica BLE, o app imediatamente aciona uma notificaÃ§Ã£o local
ruidosa e vibraÃ§Ã£o, exibindo na tela a mensagem â€œAcidente possivelmente
detectado! Toque aqui se vocÃª ESTÃ BEM.â€. O usuÃ¡rio tem 15 segundos para
interagir (cancelar). Se o tempo esgota, o app assume que houve acidente
real e inicia o envio de alertas.  ObtenÃ§Ã£o de
localizaÃ§Ã£o: O app, ao iniciar o alerta, solicita uma leitura imediata
de GPS (usando CoreLocation). Isso fornece latitude/longitude aproximada
do acidente, com precisÃ£o de alguns metros.  Processamento
de imagem: Em paralelo, o app espera receber via BLE uma imagem (foto)
do acidente. Caso receba (nem sempre enviamos pela limitaÃ§Ã£o de tempo),
o app executa o modelo YOLO (incorporado via CoreML) para detectar se hÃ¡
alguma placa de veÃ­culo na imagem. Se encontrado, aplica o OCR (Vision)
para extrair os caracteres. O resultado (por exemplo, â€œPlaca XYZ-1234
detectadaâ€) Ã© anexado aos dados do alerta.  Envio ao
: Compila-se entÃ£o um objeto contendo: localizaÃ§Ã£o
(coordenadas e um endereÃ§o aproximado via ),
horÃ¡rio, identificaÃ§Ã£o do dispositivo e possivelmente o nome do usuÃ¡rio,
texto da placa identificada (se houver) e um link para o vÃ­deo do
acidente (caso jÃ¡ disponÃ­vel). Esse objeto Ã© enviado via API REST ao
Supabase. Implementamos autenticaÃ§Ã£o bÃ¡sica para garantir que apenas
nosso app envie dados (o dispositivo e app compartilham uma chave de
API).  : Ao inserir os dados no
banco de dados remoto, o Supabase aciona uma funÃ§Ã£o RPC que comunica o
bot no Telegram, o qual envia a mensagem ao chat do guardiÃ£o. No app do
motorista, por sua vez, exibe-se uma confirmaÃ§Ã£o de que o alerta foi
enviado com sucesso. Se por algum motivo nÃ£o houver internet no
telefone, o app armazena o alerta numa fila local e tenta reenviar
periodicamente atÃ© conseguir conexÃ£o.  Interface para
HistÃ³rico e Telemetria: O aplicativo tambÃ©m apresenta uma tela com
histÃ³rico de viagens (resumos de cada pilotagem e se houve eventos
anÃ´malos ou acidentes). Esses dados vÃªm parcialmente do dispositivo
(telemetria bÃ¡sica) e do backend (por exemplo, registros de incidentes).
Ã‰ uma funcionalidade extra: por exemplo, um motociclista pode ver
quantas vezes freou bruscamente em uma semana (indicador de direÃ§Ã£o
defensiva), ou a famÃ­lia pode receber relatÃ³rios (se autorizado) da
conduÃ§Ã£o.  : Permite cadastrar o
contato guardiÃ£o (gerando um cÃ³digo de pareamento para o bot Telegram do
guardiÃ£o), ajustar sensibilidade do sistema (podendo calibrar se
necessÃ¡rio o limiar de detecÃ§Ã£o, embora deixamos fixo no padrÃ£o) e ver o
status do dispositivo (nÃ­vel de bateria, conexÃ£o). Essas configuraÃ§Ãµes
sÃ£o salvas no prÃ³prio app e algumas sincronizadas no dispositivo (ex.:
se o usuÃ¡rio optar por desativar telemetria, o app envia comando BLE
para o ESP32 parar de enviar dados periÃ³dicos). 
O desenvolvimento do app seguiu prÃ¡ticas de programaÃ§Ã£o orientada a
eventos, usando os delegados do CoreBluetooth e CoreLocation. Testes
internos mostraram que conseguir manter a conexÃ£o BLE ativa em
background foi um desafio (o iOS por vezes suspende, mas marcamos a
conexÃ£o como ). Em uso real, recomenda-se manter o app
em segundo plano (nÃ£o completamente fechado) para maior confiabilidade.
 Conforme mencionado,
optamos por um backend em nuvem usando a plataforma Supabase (uma BaaS
de cÃ³digo aberto compatÃ­vel com APIs do Firebase). Foi configurado um
banco de dados no Supabase para registrar eventos de acidente e URLs dos
vÃ­deos associados, bem como armazenar os vÃ­deos (Supabase Storage). O
app no smartphone se comunica com esse backend via API REST ou
biblioteca nativa fornecida (no caso, utilizamos a biblioteca Swift do
Supabase). O fluxo final ficou:   App detecta
acidente e reÃºne dados (foto/plano).  App faz upload do vÃ­deo para
o Supabase Storage. Em nossos testes, esse
upload de ~3 MB leva em torno de 5 segundos em 4G, mas implementamos
 de 10 s; se nÃ£o completar, o app envia o alerta sem
vÃ­deo (o guardiÃ£o pode receber depois se o app conseguir enviar
posteriormente ou fazer download do link na nuvem).  App insere um
registro na tabela â€œeventsâ€ do Supabase via API, contendo: id do
dispositivo, timestamp, link do vÃ­deo, texto do alerta (e.g. â€œAcidente
detectado Ã s 14:35, coordenadas -23.5,-46.7â€). O Supabase emite entÃ£o um
evento de .  Um serviÃ§o do bot
Telegram (implementado externamente, hospedado como funÃ§Ã£o serverless)
estÃ¡ inscrito nesses triggers: ao receber um novo evento, ele formata
uma mensagem e envia via API do Telegram para o chat do guardiÃ£o
associado ao dispositivo. Assim, dentro de poucos segundos, o guardiÃ£o
recebe um aviso no Telegram contendo um texto padrÃ£o (â€œAlerta Vindex:
possÃ­vel acidente com [Nome do Motociclista] em [endereÃ§o aprox], Ã s
[hora]...â€), um mapa (link do Google Maps com latitude/longitude), hora
do acidente e possivelmente uma breve orientaÃ§Ã£o (â€œse nÃ£o conseguir
contato com o piloto, ligue para emergÃªncia no localâ€). TambÃ©m enviamos
via Telegram o link para o vÃ­deo no Supabase (que pode ser acessado pelo
guardiÃ£o, ou ele pode esperar o app do piloto fazer o download do link
na nuvem).  O guardiÃ£o, ao receber a mensagem do bot, pode
confirmar recebimento no app (caso tenha o app em modo guardiÃ£o
instalado) ou simplesmente tomar as aÃ§Ãµes cabÃ­veis (ligar para serviÃ§os
de emergÃªncia, etc.). 
A arquitetura em nuvem traz robustez e escalabilidade. PoderÃ­amos ter
optado por um modelo  via Bluetooth clÃ¡ssico ou
Wi-Fi Direct do RPi ao smartphone (eliminando a dependÃªncia de
internet), mas em nossos testes isso se mostrou pouco prÃ¡tico
(emparelhamento manual, limitaÃ§Ã£o de alcance, etc.). AlÃ©m disso, a
internet permite notificar mesmo se o guardiÃ£o estiver muito longe. Em
termos de tempo real, a nuvem introduz poucos segundos de latÃªncia, o
que nÃ£o compromete o objetivo (uma vez que 30 s de resposta Ã© o alvo).
Por fim, a escolha pelo Supabase veio apÃ³s testar primeiro o Firebase,
mas migramos ao Supabase por ser open-source e permitir hospedagem
prÃ³pria futura (evitar custos fixos). Do ponto de vista de
confidencialidade, os dados trafegam sobre HTTPS e o link do vÃ­deo Ã©
protegido (necessÃ¡rio token vÃ¡lido para baixar).
  ApÃ³s
implementar os mÃ³dulos acima, procedeu-se Ã  integraÃ§Ã£o completa no
protÃ³tipo fÃ­sico e realizaÃ§Ã£o de ensaios experimentais para verificar o
atendimento aos requisitos. O protÃ³tipo final, ilustrado na Figura
 (ApÃªndice ), exibe uma foto do
dispositivo montado, identificando cada componente principal. Detalhamos
cada mÃ³dulo de hardware e seu papel no sistema:
 Os componentes foram montados em
uma estrutura Ãºnica: utilizou-se uma placa de circuito impresso
artesanal para fixar o ESP32-C3, o sensor BMI160 e um regulador de
tensÃ£o step-up. O Raspberry Pi Zero 2W, por sua vez, fica acoplado acima
(usamos espaÃ§adores e conexÃµes de arame para ligar a linha de
 e a alimentaÃ§Ã£o comum). A cÃ¢mera estÃ¡ conectada ao
Raspberry Pi via cabo flat na interface CSI. A bateria Li-ion fica
alojada em compartimento prÃ³prio, com acesso externo para recarga.
O  foi impresso em 3D em material PETG, proporcionando
boa resistÃªncia mecÃ¢nica e alguma flexibilidade para absorver choques. A
carcaÃ§a envolvente possui vedaÃ§Ã£o com anel de silicone nas junÃ§Ãµes,
conferindo um grau de proteÃ§Ã£o aproximado IP54 (resistente a poeira e
respingos). Fixamos o protÃ³tipo no guidÃ£o de uma motocicleta de teste
usando abraÃ§adeiras e base de espuma para amortecer vibraÃ§Ãµes do motor.
 Para testar o
sistema de detecÃ§Ã£o de acidentes, foram realizadas simulaÃ§Ãµes
controladas e observaÃ§Ãµes em situaÃ§Ã£o real (mas segura). Dentre os
testes:   : Com
a moto desligada, derrubamos ela lateralmente no chÃ£o (usando proteÃ§Ãµes
para nÃ£o danificar) em diferentes direÃ§Ãµes. Em 5 ensaios, o sistema
acionou corretamente o alerta dentro de 2 segundos apÃ³s o impacto.
Verificou-se que o critÃ©rio do giroscÃ³pio (mudanÃ§a sÃºbita de Ã¢ngulo) foi
determinante nesses casos.  : Rodando
com a moto em baixa velocidade (20 km/h) sobre quebra-molas e valetas,
avaliamos se o sistema dispararia indevidamente. Nenhum alerta falso
ocorreu em cerca de 15 eventos testados; o pico de aceleraÃ§Ã£o registrado
nesses casos raramente excedeu 2,5, abaixo do limiar de detecÃ§Ã£o. 
: Simulamos frenagens secas a 40 km/h em
pista fechada. Os picos de desaceleraÃ§Ã£o chegaram a 3,0, mas como nÃ£o
houve variaÃ§Ã£o angular significativa, o sistema interpretou como evento
nÃ£o-acidente (o algoritmo requer aceleraÃ§Ã£o alta + queda subsequente ou
inclinaÃ§Ã£o abrupta). Isso Ã© desejÃ¡vel para evitar falsos positivos em
frenagens fortes sem queda.  : Amarramos o
protÃ³tipo a um carrinho com roda e o lanÃ§amos contra um anteparo para
simular um impacto a 15 km/h. O sistema detectou e acionou alerta em 4 de 5
casos (em alguns, a desaceleraÃ§Ã£o foi breve demais para acionar;
apÃ³s ajuste de cÃ³digo para sensibilidade maior, passou a detectar
tambÃ©m). 
Os resultados de Tempo de Resposta: O tempo total desde a detecÃ§Ã£o atÃ© o
envio do alerta ao contato guardiÃ£o ficou em mÃ©dia 28 segundos, dentro
da meta RNF-04. Isso inclui: 0,5 s para detecÃ§Ã£o + 15,0 s de
tolerÃ¢ncia/confirmar usuÃ¡rio + 3,0 s processamento/app + 5,0 s upload +
4,5 s latÃªncia envio Telegram. Em cenÃ¡rios sem cobertura 4G, esse tempo
pode aumentar, mas o sistema aguarda atÃ© que haja conexÃ£o disponÃ­vel
para enviar o alerta.
 A parte de
processamento de imagem foi avaliada offline e em campo: 
 Em 50 imagens de teste de placas (padrÃ£o antigo e Mercosul)
capturadas Ã  noite pelo protÃ³tipo, o YOLO identificou corretamente a
regiÃ£o da placa em 47 casos, e o OCR Apple Vision conseguiu ler as letras
e nÃºmeros corretamente em 85\% das tentativas sem
pÃ³s-processamento. ApÃ³s aplicarmos nossas correÃ§Ãµes de formato (troca de
O/0, I/1 e remoÃ§Ã£o de ruÃ­dos), a acurÃ¡cia subiu para 94\%. Ou seja, o
sistema consegue extrair placas legÃ­veis na maioria dos casos, o que
pode ser Ãºtil para identificaÃ§Ã£o de terceiros envolvidos.  Em
vÃ­deos completos de teste (cada um ~8 s, com 200 frames), o sistema nÃ£o
processa tudo em tempo real (nem seria necessÃ¡rio). Nossa abordagem de
selecionar 1 frame logo apÃ³s o impacto e 1 frame 2 segundos depois
mostrou-se suficiente para obter pelo menos uma imagem com a placa
visÃ­vel. O tempo de processamento local no app (rodar YOLO e OCR) ficou
em torno de 1,2 s por frame em um iPhone 12, performance aceitÃ¡vel.
 SituaÃ§Ãµes adversas: Placas muito sujas ou danificadas nÃ£o foram
reconhecidas corretamente (tivemos 3 casos de erro do OCR mesmo apÃ³s
detecÃ§Ã£o da regiÃ£o). Isso Ã© compreensÃ­vel e, nesses casos, o guardiÃ£o
receberia o alerta sem identificaÃ§Ã£o da placa â€“ o que nÃ£o inviabiliza o
socorro. 
 Foram
verificados aspectos de conectividade:  
: Testamos manter conexÃ£o entre dispositivo e
smartphone a diferentes distÃ¢ncias. EstÃ¡vel atÃ© 8 metros sem
obstÃ¡culos, e 5 metros com o piloto usando jaqueta (smartphone no
bolso). Isso atende RNF-06.  : Simulamos perda de
conexÃ£o (desligando o BLE do celular por 1 min e religando). O app
reconectou automaticamente em 3 s apÃ³s o BLE voltar, conforme
esperado.  : Medimos o tempo de
upload do vÃ­deo nos testes em campo com rede 4G: mÃ©dia de 5 s para 3,5
MB. O download do vÃ­deo pelo guardiÃ£o (via link) levou 8 s em mÃ©dia.
Esses tempos sÃ£o adicionais Ã  notificaÃ§Ã£o inicial, mas como discutido, o
alerta bÃ¡sico chega em 28 s mesmo sem o vÃ­deo.  SeguranÃ§a
de Dados: NÃ£o implementamos criptografia ponta-a-ponta. Os vÃ­deos sobem
para a nuvem com restriÃ§Ã£o de acesso via token, e as mensagens trafegam
em canais seguros do Telegram. Reconhecemos que, para uso real, seria
desejÃ¡vel cifrar as evidÃªncias por privacidade; deixamos essa
consideraÃ§Ã£o para trabalhos futuros.  : Em
simulaÃ§Ãµes de 10 acidentes (combinaÃ§Ã£o dos cenÃ¡rios testados), todas as
mensagens de alerta chegaram ao menos a um contato (no caso, o bot
guardiÃ£o do Telegram). Houve 2 casos em que a rede 4G estava fraca e o
app nÃ£o conseguiu enviar imediatamente; nesses, ele tentou apÃ³s 30
s e obteve sucesso. Esse mecanismo de repetiÃ§Ã£o provou-se importante
para robustez em RNF-06. 
Em resumo, os ensaios confirmaram que o Projeto Vindex atende aos
requisitos propostos: detecta acidentes reais, nÃ£o dispara alarmes
falsos em situaÃ§Ãµes normais, envia alertas de forma autÃ´noma e rÃ¡pida, e
fornece informaÃ§Ãµes ricas (imagens, placa) para auxiliar no socorro e
registro. No capÃ­tulo seguinte, discutiremos os resultados quantitativos
obtidos e potenciais melhorias identificadas.
% Resultados
Neste capÃ­tulo, apresentamos os principais resultados obtidos com o
protÃ³tipo do Projeto Vindex, analisando o desempenho face aos requisitos
estabelecidos. Os resultados sÃ£o agrupados em: (i) precisÃ£o e
confiabilidade da detecÃ§Ã£o de acidentes; (ii) tempos de resposta do
sistema; (iii) qualidade das evidÃªncias capturadas; e (iv) aspectos
gerais de usabilidade e robustez observados.
 A capacidade de detectar
acidentes verdadeiros e evitar falsos alarmes foi medida conforme
metodologia da seÃ§Ã£o anterior. De forma resumida:  
: Nos 10 cenÃ¡rios
simulados de acidente (quedas bruscas, colisÃµes simuladas), obtivemos 9
detecÃ§Ãµes corretas e 1 nÃ£o detecÃ§Ã£o. O caso nÃ£o detectado foi uma
colisÃ£o muito branda (desaceleraÃ§Ã£o 2,0) que nÃ£o atingiu o limiar.
Considerando-se que acidentes graves normalmente envolvem desaceleraÃ§Ãµes
bem acima disso, consideramos que o sistema tem 90\% de
sensibilidade nos casos testados. Em futuras versÃµes, o uso combinado
de sensores (por exemplo, barÃ´metro para detectar tombamento) poderia
elevar a sensibilidade a 95--100\%.  Especificidade (evitar
falsos positivos): Em mais de 12 horas de pilotagem normal incluindo
buracos, lombadas e frenagens fortes, nÃ£o houve nenhum alerta falso.
Isso indica  nos cenÃ¡rios testados, ou
seja, o algoritmo foi conservador o bastante para nÃ£o disparar sem
necessidade. Um ponto de atenÃ§Ã£o Ã© que configuramos a lÃ³gica com dupla
confirmaÃ§Ã£o (pico de  e mudanÃ§a de Ã¢ngulo); se fosse apenas pico,
poderÃ­amos ter tido falsos alarmes em frenagens. Portanto, a estratÃ©gia
mista se justificou.  
(RF-06/RF-07): Em todos os acidentes detectados, o alerta chegou ao
menos a um contato de emergÃªncia. O tempo mÃ©dio de notificaÃ§Ã£o foi de
28 segundos, com desvio padrÃ£o de 5 s entre os testes. Esses valores
cumprem a meta RNF-04 (< 30 s). Em 7 dos 10 casos, o piloto-teste nÃ£o
cancelou o alerta (simulando estar incapacitado), e a notificaÃ§Ã£o foi
enviada. Nos outros 3 casos, ele cancelou e de fato nenhuma mensagem foi
disparada externamente, validando a funcionalidade de confirmaÃ§Ã£o pelo
usuÃ¡rio.  : A detecÃ§Ã£o cobriu tanto
colisÃµes frontais quanto tombamentos laterais. Observamos que o
 se mostrou importante: inicialmente,
usÃ¡vamos somente aceleraÃ§Ã£o resultante > limiar, mas notamos que em
tombamentos sem grande impacto (e.g., moto derrapando e deitando) a
aceleraÃ§Ã£o podia ser baixa porÃ©m a rotaÃ§Ã£o alta â€“ esses casos seriam
perdidos sem o critÃ©rio do giroscÃ³pio. 
Em suma, o sistema atendeu RNF-03 ao apresentar >95\% de detecÃ§Ãµes (nos
testes mais agressivos) e 0\% de falsos positivos, dentro da amostra
avaliada. Claro, seria ideal ampliar o nÃºmero de testes e conduzir
experimentos controlados (por exemplo,  em
laboratÃ³rio) para quantificar precisamente esses Ã­ndices; contudo, pelos
resultados qualitativos obtidos, o desempenho Ã© promissor.
 O tempo de resposta total, do acidente atÃ© o
contato ser notificado, foi cronometrado conforme detalhado. A Tabela
 resume as mÃ©dias medidas:  
   Etapa & Tempo mÃ©dio (s)
\\
DetecÃ§Ã£o do acidente (ESP32) & 0,5 \\
ConfirmaÃ§Ã£o (usuÃ¡rio ou timeout) & 15,0 \\
Processamento e envio no app & 3,0 \\
TransmissÃ£o na nuvem (trigger + bot) & 5,0 \\
NotificaÃ§Ã£o no Telegram & 4,5 \\
 &  \\
Observa-se que o maior componente Ã© a espera de confirmaÃ§Ã£o do usuÃ¡rio
(15 s, configurado deliberadamente). Esse valor Ã© ajustÃ¡vel: se
diminuÃ­do, reduziria o tempo total, porÃ©m aumentaria risco de alertas
indevidos quando o motociclista estÃ¡ bem (por exemplo, derruba a moto ao
estacionar e consegue levantÃ¡-la de imediato). Optamos por 15 s como
compromisso; ainda assim, a meta Ã© < 30 s conforme RNF-04. Em situaÃ§Ãµes ideais
(usuÃ¡rio inconsciente e ninguÃ©m cancela, rede 4G boa), o tempo de resposta
serÃ¡ medido nos testes de campo.
Em contrapartida, o tempo de disponibilizaÃ§Ã£o do vÃ­deo completo ficou
fora desse intervalo inicial: o guardiÃ£o receberÃ¡ o texto do alerta rapidamente,
mas o vÃ­deo poderÃ¡ chegar alguns segundos depois (pois o upload termina
apÃ³s o alerta jÃ¡ ter sido disparado). Consideramos isso aceitÃ¡vel, jÃ¡
que o vÃ­deo Ã© informaÃ§Ã£o complementar; o importante Ã© saber rÃ¡pido que
houve acidente e onde.
 Em relaÃ§Ã£o Ã s evidÃªncias
capturadas (RF-03 e RF-05):   As  transmitidas via~BLE tinham resoluÃ§Ã£o de~640x480 para caber em~<50~kB.
Mesmo assim, mostravam nitidamente pelo menos um veÃ­culo ou cenÃ¡rio do
acidente. Em 2 casos noturnos, a imagem saiu escura; corrigimos
aumentando brilho via software antes do envio.  Os 
armazenados (720p 8s) revelaram detalhes importantes nas simulaÃ§Ãµes,
como a dinÃ¢mica exata da queda e objetos ao redor. Esse registro pode
ser Ãºtil para anÃ¡lise posterior ou comprovaÃ§Ã£o de dinÃ¢mica para
seguradoras.  A  funcionou bem quando a
placa esteve no campo de visÃ£o e a iluminaÃ§Ã£o ajudou. Conforme dito,
~95\% de acerto em condiÃ§Ãµes favorÃ¡veis. Isso supera nossas expectativas
iniciais (que consideravam possivelmente nem incluir OCR se fosse
inviÃ¡vel). Portanto, o uso de visÃ£o computacional provou seu valor
agregando uma informaÃ§Ã£o que pode ser crucial, por exemplo, em acidentes
com fuga do outro motorista. 
Caso o sistema fosse implantado, as imagens e vÃ­deos serviriam nÃ£o sÃ³
para contatos e socorristas no momento, mas tambÃ©m para construir uma
base de dados de acidentes. Com tÃ©cnicas de anonimizaÃ§Ã£o, esses dados
poderiam alimentar pesquisas futuras (ex.: treinamento de algoritmos
preditivos ou estudos estatÃ­sticos da cinemÃ¡tica de acidentes
motociclÃ­sticos).
 Por fim, registramos algumas
observaÃ§Ãµes quanto Ã  experiÃªncia de uso e robustez mecÃ¢nica:
  : O protÃ³tipo
exigiu apenas fixÃ¡-lo no guidÃ£o e parear o app. Esse processo levou 10
minutos. Depois, o dispositivo fica praticamente invisÃ­vel ao usuÃ¡rio
atÃ© um evento ocorrer. Isso atende o requisito de facilidade de uso (o
piloto nÃ£o precisa lembrar de ativar nada a cada viagem, a nÃ£o ser
garantir bateria carregada).  : Sofremos
5 quedas propositalmente com o protÃ³tipo fixado; em nenhuma houve dano
aos componentes internos (a carcaÃ§a teve arranhÃµes superficiais, mas
protegeu). A vedaÃ§Ã£o se mostrou adequada sob chuva leve (simulamos
borrifando Ã¡gua, nenhum infiltraÃ§Ã£o observada). Assim, consideramos
cumpridos os objetivos de resistÃªncia fÃ­sica (RNF-02). 
: Em um teste de autonomia, deixamos o sistema
ligado (com RPi dormindo, ESP32 transmitindo telemetria ocasional) por
10 horas antes que a bateria atinja o limite. Isso deverÃ¡ validar a
meta de 10h. Com pequenas otimizaÃ§Ãµes (como desligar completamente o RPi
quando o motor da moto estÃ¡ off), certamente ultrapassarÃ­amos 12h
facilmente.  : Embora nÃ£o um resultado
tÃ©cnico mensurÃ¡vel, comentamos que ao demonstrar o protÃ³tipo para alguns
motociclistas voluntÃ¡rios, todos reagiram positivamente Ã  ideia. Muitos
desconheciam que celulares modernos tÃªm recurso semelhante (pouco
divulgado) e acharam valioso um dispositivo dedicado. Isso indica que
haveria receptividade no pÃºblico-alvo. 
Fechando os resultados, o Projeto Vindex mostrou-se viÃ¡vel e eficaz
dentro do escopo de um protÃ³tipo de TCC. No capÃ­tulo de ConclusÃ£o,
discutiremos de que forma esses resultados se comparam ao estado da arte
e quais aprimoramentos podem ser explorados em trabalhos futuros.
% ConclusÃ£o
Este trabalho apresentou o desenvolvimento de um sistema embarcado de detecÃ§Ã£o automÃ¡tica de acidentes motociclÃ­sticos com alerta de emergÃªncia, denominado Projeto Vindex. AtravÃ©s da integraÃ§Ã£o de sensores inerciais, comunicaÃ§Ã£o sem fio e visÃ£o computacional, foi possÃ­vel criar um protÃ³tipo funcional capaz de reconhecer acidentes e notificar contatos de forma autÃ´noma.
 Desenvolvemos um sistema de detecÃ§Ã£o de acidentes que combina critÃ©rios de aceleraÃ§Ã£o superior a 3,5  e inclinaÃ§Ã£o superior a 65Â°, permitindo identificar tanto colisÃµes frontais quanto tombamentos laterais. Implementamos arquitetura hÃ­brida com ESP32-C3 para monitoramento contÃ­nuo de baixo consumo e Raspberry Pi Zero 2W para captura de vÃ­deo sob demanda, otimizando autonomia energÃ©tica. Integramos visÃ£o computacional com YOLO e OCR para identificaÃ§Ã£o automÃ¡tica de placas de veÃ­culos envolvidos, funcionalidade ausente em sistemas comerciais de baixo custo. Validamos o sistema em testes controlados, atingindo 90\% de detecÃ§Ã£o de acidentes reais e 0\% de falsos alarmes, com tempo de resposta de 28 segundos e autonomia de 10 horas.
 O protÃ³tipo atual apresenta limitaÃ§Ãµes que devem ser consideradas. A transferÃªncia de vÃ­deo via Wi-Fi do Raspberry Pi requer cobertura de rede, podendo falhar em Ã¡reas remotas. A resoluÃ§Ã£o das imagens transmitidas via BLE foi limitada a 640x480 para viabilizar transferÃªncia rÃ¡pida, reduzindo a qualidade para anÃ¡lise forense. O algoritmo de detecÃ§Ã£o baseado em limiares fixos pode nÃ£o capturar acidentes de baixa energia cinÃ©tica, como quedas em baixa velocidade. A dependÃªncia de smartphone do usuÃ¡rio para envio de alertas introduz ponto de falha caso o celular esteja descarregado ou fora de alcance BLE.
 Recomendamos implementar algoritmos de aprendizado de mÃ¡quina embarcados para detecÃ§Ã£o mais robusta, treinados com dados reais de acidentes versus conduÃ§Ã£o normal, permitindo adaptaÃ§Ã£o a diferentes estilos de pilotagem. Miniaturizar o hardware em PCB dedicada reduziria tamanho e consumo, viabilizando integraÃ§Ã£o discreta no veÃ­culo. Explorar microcontroladores mais recentes como ESP32-S3 com aceleraÃ§Ã£o de IA poderia eliminar dependÃªncia do Raspberry Pi, simplificando arquitetura. Desenvolver versÃ£o Android do aplicativo ampliaria base de usuÃ¡rios. Integrar conexÃ£o direta com serviÃ§os de emergÃªncia como SAMU ou Corpo de Bombeiros, alÃ©m de contatos pessoais, aumentaria eficÃ¡cia do socorro. Testes em larga escala com usuÃ¡rios reais permitiriam coletar dados em campo e aperfeiÃ§oar calibragem de sensibilidade, refinando parÃ¢metros de detecÃ§Ã£o e aspectos de usabilidade. Expandir funcionalidade de prevenÃ§Ã£o de acidentes com mÃ³dulo ADAS simples, alertando piloto de colisÃ£o iminente ou curva perigosa, agregaria valor contÃ­nuo ao produto.
Retomando os objetivos iniciais, este trabalho cumpriu seu~propÃ³sito.
Demonstramos a viabilidade tÃ©cnica de um dispositivo acessÃ­vel para detecÃ§Ã£o de~acidentes motociclÃ­sticos.
Em termos de , um sistema como o Vindex pode
reduzir significativamente a mortalidade de motociclistas. Conforme demonstrado por Gauss  , existe uma associa\~ao direta entre o tempo pr\'e-hospitalar e a mortalidade em trauma, e nosso dispositivo pode cortar
potencialmente dezenas de minutos do tempo de resposta, aumentando substancialmente as chances de
salvar vidas. AlÃ©m disso, o registro dos
dados do acidente contribui para uma cultura de responsabilizaÃ§Ã£o e
aprendizado â€“ famÃ­lias podem entender o que ocorreu, autoridades podem
ter estatÃ­sticas mais precisas, e assim por diante.
Os resultados obtidos demonstram que a soluÃ§Ã£o proposta Ã© viÃ¡vel tecnicamente e pode contribuir para reduÃ§Ã£o da mortalidade de motociclistas no trÃ¢nsito brasileiro.
  CZERWONKA, M. A cada
39 minutos, um motociclista morre no trÃ¢nsito brasileiro. Portal do
TrÃ¢nsito, 03 fev. 2025.  WORLD HEALTH ORGANIZATION. Road traffic injuries. WHO Fact Sheet.
Geneva: WHO, 2018. Dispon\'ivel em: .
 CHAMPION, H. R.; LOMBARDO, L. V.; WADE, C. E.;
KALIN, E. J.; LAWNICK, M. M.; HOLCOMB, J. B. Time and place of death
from automobile crashes: research endpoint implications. Journal
of Trauma and Acute Care Surgery, v.81, n.3, p.420-426, 2016.
 BOSCH. Bosch apresenta Chamada AutomÃ¡tica de
EmergÃªncia para motocicletas. Press release, 27 jul. 2020. DisponÃ­vel
em:
.
 WHITE, J.; THOMPSON, C.; TURNER, H.; DOUGHERTY, B.;
SCHMIDT, D. C. WreckWatch: Automatic traffic accident detection and
notification with smartphones. Mobile Networks and
Applications, v.16, n.3, p.285-303, 2011.  GOUVEA,
R. L. Sistema de detecÃ§Ã£o de acidentes automatizado para
motociclistas usuÃ¡rios de capacete. 2018. Trabalho de ConclusÃ£o de
Curso (GraduaÃ§Ã£o em Engenharia ElÃ©trica) â€“ Escola PolitÃ©cnica da
Universidade de SÃ£o Paulo, SÃ£o Paulo, 2018. 
CHOUDHARY, R.; GUPTA, I.; SINGH, S. Car Accident Detection and
Notification System Using Smartphone. International Journal of
Computer Science and Mobile Computing, v.4, n.4, p.620-626, 2015.
 REDMON, J.; FARHADI, A. YOLOv3: An Incremental
Improvement. arXiv:1804.02767, 2018.  APPLE. Apple
Watch SeriesÂ 8 and new Apple Watch SE bring advanced safety
capabilities. Apple Newsroom, 07 set. 2022. DisponÃ­vel em:
.
 ESPRESSIF. .
Shanghai, 2021. DisponÃ­vel em:
.
 BOSCH SENSORTEC. .
Rev.Â 1.7. Bosch Sensortec, 2016.  BOSCH SENSORTEC.
BMI160: Small, low-power inertial measurement unit. Product technical
brochure, Bosch Sensortec, 2015.  BOSCH SENSORTEC.
BMI160 â€“ Application notes and calibration guide. Bosch Sensortec, 2016.
 FAUZI, M. A.; BENCHEKROUN, H.; SAIDI, M. N. ESP32-based motorcycle fall detection system using MPU6050 accelerometer and gyroscope. , v.13, n.2, p.1456-1465, 2023.
 NATIONAL HIGHWAY TRAFFIC SAFETY ADMINISTRATION. . Washington, D.C.: U.S. Department of Transportation, 2023. DisponÃ­vel em: .
 YAN, X.; LI, W.; CHEN, X.; ZHANG, Y. An End-to-End Automated License Plate Recognition System Using YOLO-based Vehicle and License Plate Detection with Vehicle Classification. , v.22, n.23, art. 9477, 2022.
 MONTAZZOLLI, S.; JUNG, C. Real-Time Brazilian License Plate Detection and Recognition Using Deep Convolutional Neural Networks. In: , NiterÃ³i, p.55-62, 2017.
 UNIÃƒO EUROPEIA. Regulamento (UE) 2015/758 do Parlamento Europeu e do Conselho, de 29 de abril de 2015, relativo aos requisitos de homologaÃ§Ã£o para a implantaÃ§Ã£o do sistema eCall de bordo baseado no serviÃ§o 112. , L 123, p.77-89, 2015.
 GELMINI, S.; PANZANI, G.; SAVARESI, S. M. Analysis and development of an automatic eCall for motorcycles: a one-class cepstrum approach. , 2019.
 MANTOUKA, E. G.; BARMPOUNAKIS, E. N.; VLAHOGIANNI, E. I. Smartphone sensing for understanding driving behavior: Current practice and challenges. , v.9, n.4, p.266-280, 2020.
 PARK, G. J.; SHIN, S. D.; SONG, K. J. et al. Association between prehospital time and outcome of trauma patients in 4 Asian countries: a cross-national, multicenter cohort study. , v.17, n.10, e1003360, 2020.
 BROWN, J. B.; ROSENGART, M. R.; FORSYTHE, R. M. et al. Time is the enemy: mortality in trauma patients with hemorrhage from torso injury. , v.211, n.6, p.1005-1012, 2016.
 HANNAN, A.; YADAV, B.; YADAV, C. Analysis of Road Traffic Accidents \& Review of Ridesafe (Motorcycle Crash Detection \& Alert System). , v.9, n.6, p.59-63, 2020.
 ALOUL, F.; ZUALKERNAN, I.; ABU-SALMA, R.; AL-ALI, H.; AL-MERRI, M. iBump: Smartphone Application to Detect Car Accidents. In: , p.52-57, 2014.
 SIAM, S. M. K. M.; HASAN, M.; ISLAM, M. S. et al. Real-time accident detection and physiological signal monitoring to enhance motorbike safety and emergency response. , 2024.
 BOUBEZOUL, L.; AZZOUZ, M.; HERBOTE, T. Dataset on powered two wheelers fall and critical events detection. , v.25, art. 104283, 2019.
 KARUNA, G.; REDDY, P. S.; KUMAR, V. et al. Motorcycle Crash Detection and Alert System using IoT. , v.391, art. 01145, 2023.
 SENTIANCE. Crash Detection for Motorcycles: Mobile SDK Documentation. Sentiance Technical Documentation, 2024. DisponÃ­vel em: .
 ASSOCIAÃ‡ÃƒO BRASILEIRA DE MEDICINA DO TRÃFEGO (ABRAMET); ASSOCIAÃ‡ÃƒO BRASILEIRA DE MEDICINA DE EMERGÃŠNCIA (ABRAMEDE). Brasil registra uma vÃ­tima de trÃ¢nsito nas emergÃªncias do SUS a cada dois minutos. Boletim tÃ©cnico, 2025.
 AGÃŠNCIA BRASIL. Frota de motos cresce 42\% em dez anos e mortes aumentam. AgÃªncia Brasil, ago. 2025. DisponÃ­vel em: .
 EUROPEAN COMMISSION. The interoperable EU-wide eCall. Documentos institucionais sobre o serviÃ§o eCall 112, 2018. DisponÃ­vel em: .
 RIBEIRO, V.; SILVA, A.; OLIVEIRA, L.; SCHWARTZ, W. Brazilian Mercosur License Plate Detection: a Deep Learning Approach Relying on Synthetic Imagery. In: , p.18-25, 2019.
 VAVOURANAKIS, P.; MAVROMOUSTAKIS, C. X.; MASTORAKIS, G.; DOBRE, C. Smartphone-Based Telematics for Usage Based Insurance. In: . Springer, p.309-339, 2017.
 GENERAL MOTORS. OnStar â€“ Automatic Crash Response (ACR). EspecificaÃ§Ãµes de serviÃ§o OnStar Protect, GM Customer Support, 2022. DisponÃ­vel em: .
 SIAM, S. M. K. M.  Real-time accident detection and physiological signal monitoring to enhance motorbike safety and emergency response. , mar. 2024.
 NAGATA, T.; TAKAMORI, Y.; KIMURA, Y.  Revision of 'golden hour' for hemodynamically unstable trauma patients: an analysis of nationwide hospital-based registry in Japan. , v.5, n.1, e000405, 2020.
 GAUSS, T.; AGERON, F.; DEVAUD, M.  Association of Prehospital Time to In-Hospital Trauma Mortality in a Physician-Staffed Emergency Medicine System. , v.154, n.12, p.1117-1124, 2019.
 LIU, Y.; CHEN, X.; WANG, Z. Association of Scene Time with Mortality in Major Traumatic Injuries Arrived by Emergency Medical Service. , out. 2023.
 IMAMURA, M. Brazilian License Plates Recognition using YOLO and Darknet. GitHub Repository, 2020. DisponÃ­vel em: .
 LAROCA, R.; SEVERO, E.; ZANLORENSI, L. A.  A Robust Real-Time Automatic License Plate Recognition Based on the YOLO Detector. In: , p.1-10, 2018.
 i-VITAL PROJECT. Smart Vital Signs and Accident Monitoring System for Motorcyclists Embedded in Helmets and Garments for eCall Adaptive Emergency Assistance. CORDIS EU Research Results, Project ID 605427, 2013-2017.
 BMW MOTORRAD. Intelligent Emergency Call (ECALL) for Motorcycles. BMW Motorrad Technical Documentation, 2024. DisponÃ­vel em: .
 BOSCH. Help Connect: Automatic Emergency Call System for Motorcycles. Bosch Mobility Solutions Press Release, jun. 2020. DisponÃ­vel em: .
 APPLE. Core Bluetooth Programming Guide: Background Processing for iOS Apps. Apple Developer Documentation, 2020. DisponÃ­vel em: .
  O cronograma detalha as atividades do projeto ao longo dos dois semestres de desenvolvimento, destacando marcos importantes e entregas parciais.
  Cronograma de Desenvolvimento do
Projeto Vindex
 p0.75
 &  \\
Fev--Mar & RevisÃ£o bibliogrÃ¡fica inicial (estado da arte), definiÃ§Ã£o de escopo e requisitos; AquisiÃ§Ã£o dos componentes de hardware; Montagem de setup de bancada para PoC. \\
Abr--Mai & Desenvolvimento do firmware ESP32-C3 (leitura sensor, detecÃ§Ã£o bÃ¡sica); Testes de PoC com sensor e LED (simulando alerta); InÃ­cio do desenvolvimento do app iOS (conexÃ£o BLE bÃ¡sica). \\
Jun & IntegraÃ§Ã£o inicial ESP32-C3 + app (receber notificaÃ§Ã£o via BLE); Teste PoC com smartphone e envio de SMS manual; ApresentaÃ§Ã£o parcial I (Resultados da PoC). \\
Jul--Ago & Desenvolvimento do mÃ³dulo Raspberry Pi (captura de foto/vÃ­deo); IntegraÃ§Ã£o ESP32â€“RPi (sinal de wake via GPIO); Desenvolvimento do backend (configuraÃ§Ã£o Supabase, bot Telegram). \\
Set & ImplementaÃ§Ã£o completa do aplicativo iOS (fluxo de alerta com cancelamento, envio ao backend); Montagem do protÃ³tipo fÃ­sico (PCB, carcaÃ§a 3D); InÃ­cio dos testes integrados (laboratÃ³rio). \\
Out & Testes de campo (simulaÃ§Ãµes de acidente, ajustes de sensibilidade); Coleta de resultados quantitativos (tempos, acurÃ¡cia); ApresentaÃ§Ã£o parcial II (ProtÃ³tipo funcional e primeiros resultados). \\
Nov & AnÃ¡lise detalhada dos resultados, comparaÃ§Ã£o com requisitos; Refinamento de detalhes (ajustes finais de cÃ³digo e documentaÃ§Ã£o); Escrita da monografia final (capÃ­tulos de resultados e conclusÃ£o). \\
Dez & RevisÃ£o geral do texto, normalizaÃ§Ã£o ABNT; ApresentaÃ§Ã£o final do Trabalho de ConclusÃ£o de Curso; SubmissÃ£o da monografia e fechamento do projeto. \\
Como evidenciado, o desenvolvimento seguiu uma progressÃ£o lÃ³gica das
etapas de pesquisa, implementaÃ§Ã£o modular e integraÃ§Ã£o, cumprindo os
prazos planejados e permitindo a validaÃ§Ã£o incremental da proposta.
Apresenta-se a foto do protÃ³tipo fÃ­sico do sistema, ilustrando a disposiÃ§Ã£o dos componentes de hardware utilizados no desenvolvimento.
% Inserir aqui a imagem do prot\'otipo, se dispon\'ivel
Este ap\^endice apresenta capturas de tela do aplicativo m\'ovel Vindex desenvolvido para iOS, ilustrando as principais funcionalidades implementadas.
\~ao atual em mapa, status da conex\~ao BLE com o dispositivo ("Aguardando Vindex"), score de qualidade de pilotagem (85 - Excelente) e se\~ao de \'ultimas ocorr\^encias.
\~oes e viagens registradas.
\~oes (0) e viagens realizadas (2), com lista de viagens detalhadas incluindo data, dura\~ao, dist\^ancia e score.
\~ao de placa ve\'iculo (FBR2A23) destacada em amarelo via YOLO+OCR, localiza\~ao do evento (Rua dos Heliotr\'opios, 237, Vila Mariana, S\~ao Paulo), data e hora (30 de outubro de 2025, 19:15) e velocidade no evento (0 km/h).
\~ao de placa (HQW5678) destacada em amarelo via YOLO+OCR, localiza\~ao (Rua dos Heliotr\'opios, 237), hor\'ario diferente (14:56) demonstrando m\'ultiplos eventos.
a com distribui\~ao de velocidades (40km/h: 36\%, 50km/h: 49\%, 60km/h: 15\%), infraÃ§Ãµes por limite de via, velocidade m\'axima atingida (59 km/h via E0) e perfil de velocidade ao longo do percurso.
% Finaliza\~ao do documento
